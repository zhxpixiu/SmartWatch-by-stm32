{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"Rx",
				"RXPhoneNum"
			],
			[
				"rx",
				"RXPhoneNum"
			],
			[
				"rt",
				"return"
			],
			[
				"DE",
				"delay_ms"
			],
			[
				"g",
				"GPRS"
			],
			[
				"de",
				"define"
			],
			[
				"tx",
				"TXPhoneNum"
			],
			[
				"RE",
				"RESET"
			],
			[
				"rtc",
				"RTC_Set"
			],
			[
				"die",
				"define"
			],
			[
				"asr",
				"ASR"
			],
			[
				"b",
				"break"
			],
			[
				"bl",
				"BLOCK_FRESH_COLOR"
			],
			[
				"re",
				"return"
			],
			[
				"R",
				"return"
			],
			[
				"cse",
				"case"
			],
			[
				"wee",
				"WEEK_DIS_POS_Y"
			],
			[
				"week",
				"WEEK_DIS_POS_X"
			],
			[
				"dat",
				"DATE_DIS_POS_Y"
			],
			[
				"s",
				"string1"
			],
			[
				"t",
				"temp"
			],
			[
				"lcd",
				"LCD_DisASCString"
			],
			[
				"ipn",
				"InputPos"
			],
			[
				"ip",
				"InputPos"
			],
			[
				"Inpu",
				"InputData"
			],
			[
				"def",
				"default"
			],
			[
				"y",
				"year"
			],
			[
				"st",
				"string"
			],
			[
				"MIN",
				"min"
			],
			[
				"HOUR",
				"hour"
			],
			[
				"o",
				"option"
			],
			[
				"ho",
				"hour"
			],
			[
				"w",
				"w_date"
			],
			[
				"ke",
				"KEEP_BG"
			],
			[
				"whi",
				"WHITE"
			],
			[
				"sec",
				"SEC_AREA"
			],
			[
				"min",
				"MIN_AREA"
			],
			[
				"bt",
				"Bt_T_Or_d_pos_x"
			],
			[
				"es",
				"else"
			],
			[
				"blo",
				"BORDER_OFF_COLOR"
			],
			[
				"bloc",
				"BLOCK_FRESH_COLOR"
			],
			[
				"lcd_",
				"LCD_DisARectangular"
			],
			[
				"H",
				"humidity"
			],
			[
				"ga",
				"GRAY"
			],
			[
				"ar",
				"AIR_CONDITIONER"
			],
			[
				"bo",
				"BLOCK_ON_COLOR"
			],
			[
				"fon",
				"FONT_COLOR_ON"
			],
			[
				"Block",
				"BLOCK_OFF_COLOR"
			],
			[
				"delay",
				"delay_ms"
			],
			[
				"lcd_dis",
				"LCD_DisARectangular"
			],
			[
				"temp",
				"temp2"
			],
			[
				"tep",
				"Temperature"
			],
			[
				"r",
				"RXdatabuf"
			],
			[
				"se",
				"sim900a_get_data"
			],
			[
				"do",
				"DOOR"
			],
			[
				"BL",
				"BLOCK_FRESH_COLOR"
			],
			[
				"B",
				"BLOCK_FRESH_COLOR"
			],
			[
				"be",
				"BEDROOM_LIGHT"
			],
			[
				"BLO",
				"BLOCK_ON_COLOR"
			],
			[
				"prin",
				"printf	printf …"
			],
			[
				"printf",
				"u2_printf"
			],
			[
				"WHIE",
				"while"
			],
			[
				"e",
				"extern"
			],
			[
				"V",
				"void"
			],
			[
				"TouchVa",
				"TouchValTemp"
			],
			[
				"LCD_Dis",
				"LCD_DisAIcon"
			],
			[
				"TouchV",
				"TouchValTemp"
			],
			[
				"v",
				"void"
			],
			[
				"Touch",
				"TouchVal"
			],
			[
				"TOUCH",
				"TOUCH_NULL"
			],
			[
				"LCD_",
				"LCD_DisABorder"
			],
			[
				"Tocu_",
				"TOUCH_NULL"
			],
			[
				"key",
				"keyValue"
			],
			[
				"TOUC",
				"TOUCH_NULL"
			],
			[
				"tou",
				"TouchVal"
			],
			[
				"C",
				"CLEAR"
			],
			[
				"cs",
				"case"
			],
			[
				"keyC",
				"KeyCountMs"
			],
			[
				"sw",
				"TouchSwitch"
			],
			[
				"n",
				"Num"
			],
			[
				"wit",
				"WHITE"
			],
			[
				"image",
				"gImage_remote"
			],
			[
				"ge",
				"Touch_GetSite"
			],
			[
				"c",
				"calendar"
			],
			[
				"inc",
				"include"
			],
			[
				"ster",
				"str_length"
			],
			[
				"str_",
				"str_height"
			],
			[
				"wh",
				"WHITE"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "#include <stdio.h>\n#include \"sim900a.h\"\n#include \"usart.h\"		\n#include \"delay.h\"	\n#include \"key.h\"	 	 	 	 	 	  \n#include \"string.h\"    		\n#include \"usart2.h\" \n#include \"rtc.h\"\n#include \"lcdlib.h\"\nu8 TXdatabuf[32];\nu8 RXdatabuf[32];\nu8 networkOption;\n// #define 27 37\n/*u8 TXPhoneNum[]=\"18825174443\";\nu8 FeixinPwd[]=\"mima8565279\";\nu8 RXPhoneNum[]=\"18826484299\";*/\n\n//ATK-SIM900A 各项测试(拨号测试、短信测试、GPRS测试)共用代码\n//usmart支持部分 \n//将收到的AT指令应答数据返回给电脑串口\n//mode:0,不清零USART2_RX_STA;\n//     1,清零USART2_RX_STA;\nu8 sim_at_response(u8 mode,u8 *rx_buf)\n{\n    u8 len=0,i;\n	\n//	if(USART2_RX_STA&0X8000)		//接收到一次数据了\n	{ \n		USART2_RX_BUF[USART2_RX_STA&0X7FFF]=0;//添加结束符\n		len=(USART2_RX_STA&0X7FFF);\n		if(len>32) len=32;\n	    for(i=0;i<len;i++) \n		rx_buf[i]=USART2_RX_BUF[i];\n		if(mode)USART2_RX_STA=0;		\n	} 	 \n	return len;\n}\n\nu8 sim_gsm_response(u8 mode,u8 *rx_buf)\n{\n    u16 len=0;\n	u16 i;	\n//	if(USART2_RX_STA&0X8000)		//接收到一次数据了\n	{ \n		len=(USART2_RX_STA&0X7FFF);\n		if(len>1) len=128;\n	    for(i=0;i<len;i++) \n		rx_buf[i]=USART2_RX_BUF[i+68];\n		if(mode)USART2_RX_STA=0;		\n	} 	 \n	return len;\n}\n//sim900a发送命令后,检测接收到的应答\n//str:期待的应答结果\n//返回值:0,没有得到期待的应答结果\n//    其他,期待应答结果的位置(str的位置)\nu8* sim900a_check_cmd(u8 *str)\n{\n	char *strx=0;\n	if(USART2_RX_STA&0X8000)		//接收到一次数据了\n	{ \n		USART2_RX_BUF[USART2_RX_STA&0X7FFF]=0;//添加结束符\n		strx=strstr((const char*)USART2_RX_BUF,(const char*)str);\n	} \n	return (u8*)strx;\n}\n//向sim900a发送命令\n//cmd:发送的命令字符串(不需要添加回车了),当cmd<0XFF的时候,发送数字(比如发送0X1A),大于的时候发送字符串.\n//ack:期待的应答结果,如果为空,则表示不需要等待应答\n//waittime:等待时间(单位:10ms)\n//返回值:0,发送成功(得到了期待的应答结果)\n//       1,发送失败\n\nu8 sim900a_send_cmd(u8 *cmd,u8 *ack,u16 waittime)\n{\n	u8 res=0; \n	USART2_RX_STA=0;\n	if((u32)cmd<=0XFF)\n	{\n		while(DMA1_Channel7->CNDTR!=0);	//等待通道7传输完成   \n		USART2->DR=(u32)cmd;\n	} else u2_printf(\"%s\\r\\n\",cmd);//发送命令\n	if(ack&&waittime)		//需要等待应答\n	{\n		while(--waittime)	//等待倒计时\n		{\n			delay_ms(10);\n			if(USART2_RX_STA&0X8000)//接收到期待的应答结果\n			{\n				if(sim900a_check_cmd(ack))break;//得到有效数据 \n				USART2_RX_STA=0;\n			} \n		}\n		if(waittime==0) res=1; \n	}\n	return res;\n} \nu8 sim900a_send1_cmd(u8 *cmd,u8 *ack,u16 waittime)\n{\n	u8 res=0; \n	USART2_RX_STA=0;\n	if((u32)cmd<=0XFF)\n	{\n		while(DMA1_Channel7->CNDTR!=0);	//等待通道7传输完成   \n		USART2->DR=(u32)cmd;\n	} else u2_printf(\"%s\",cmd);//发送命令\n	if(ack&&waittime)		//需要等待应答\n	{\n		while(--waittime)	//等待倒计时\n		{\n			delay_ms(10);\n			if(USART2_RX_STA&0X8000)//接收到期待的应答结果\n			{\n				if(sim900a_check_cmd(ack))break;//得到有效数据 \n				USART2_RX_STA=0;\n			} \n		}\n		if(waittime==0) res=1; \n	}\n	return res;\n}\nu8 	sim900a_gsm_get(u8 *data)\n{\n	u8  sim_reg=1;\n	u16 waittime=1500; \n	// u16 waittime=800; \n	u8  i;\n	u8 data1[128];\n\n	sim_reg=sim900a_send_cmd(\"AT+CMGR=27\",\"OK\",500);\n//	USART2_RX_STA=0;\n	while(--waittime)	//等待倒计时\n	{	\n		if(USART2_RX_STA&0X8000)//接收到期待的应答结果\n		{\n			sim_gsm_response(0,data1);\n\n			for(i=0;i<32;i++)\n			{\n				*(data+i)=sim900a_chr2hex(data1[(4*i+3)]);\n			}\n			*(data+0)=2;\n			*(data+1)=2;\n			sim900a_send_cmd(\"AT+CMGD=27\",\"OK\",200);	  //每次都删掉短信	\n			return sim_reg;	\n		}\n 		delay_ms(5);\n	}	  \n	if(waittime==0)\n	{							  	\n		*(data+1)=1;			\n		*(data+0)=1;\n	}\n	sim900a_send_cmd(\"AT+CMGD=27\",\"OK\",200);	  //每次都删掉短信\n    return sim_reg;\n}\n//将1个字符转换为16进制数字\n//chr:字符,0~9/A~F/a~F\n//返回值:chr对应的16进制数值\nu8 sim900a_chr2hex(u8 chr)\n{\n	if(chr>='0'&&chr<='9')return chr-'0';\n	if(chr>='A'&&chr<='F')return (chr-'A'+10);\n	if(chr>='a'&&chr<='f')return (chr-'a'+10); \n	return 0;\n}\n//将1个16进制数字转换为字符\n//hex:16进制数字,0~15;\n//返回值:字符\nu8 sim900a_hex2chr(u8 hex)\n{\n	if(hex<=9)return hex+'0';\n	if(hex>=10&&hex<=15)return (hex-10+'A'); \n	return '0';\n}\n//16进制转换成对应的字符型\nvoid xToChar(uint8_t *data,char *s)\n{\n  u8 i;\n  char temp[64];\n  for ( i=0;i<32;i++)\n  {\n     sprintf(temp,\"%x\",data[i]);\n     if (data[i]<16) strcat(s,\"0\");\n     strcat(s,temp);\n  }\n  i=0;	\n}\n\n\n//清空一个字符数组sizeof(s)*\nvoid SetNull(char *s)\n{\n \n  memset(s,0,strlen(s));\n // i=0;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////// \n//GPRS测试部分代码\n\n//sim900a GPRS测试\n//用于测试TCP/UDP连接\n//返回值:0,正常\n//    其他,错误代码\nu8 sim900a_gprs_init(void)\n{\n 	\n	if(networkOption==GPRS)\n	{\n		sim900a_send_cmd(\"AT+CSTT\",\"OK\",200);				//设置GPRS移动台类别为B,支持包交换和数据交换 \n		sim900a_send_cmd(\"AT+CIICR\",\"OK\",100);//设置PDP上下文,互联网接协议,接入点等信息\n		sim900a_send_cmd(\"AT+CIFSR\",\"OK\",200);					//附着GPRS业务\n		//http 初始化\n		sim900a_send_cmd(\"AT+HTTPTERM\",\"OK\",100);\n		sim900a_send_cmd(\"AT+SAPBR=3,1,\\\"APN\\\",\\\"CMNET\\\"\",\"OK\",200);	\n		sim900a_send_cmd(\"AT+SAPBR=1,1\",\"OK\",500);	\n		sim900a_send_cmd(\"AT+HTTPINIT\",\"OK\",200);//开http\n		sim900a_send_cmd(\"AT+CMGD=27\",\"OK\",200);	  //每次都删掉短信\n		if(sim900a_send_cmd(\"AT+HTTPPARA=\\\"CID\\\",1\",\"OK\",200)==0)\n		{\n			return 0;\n		}\n		return 1;\n	}\n	if(networkOption==ETHERNET)\n	{\n		char *p=\"AT+CIPSTART=\\\"TCP\\\",\\\"wsn604604.vicp.cc\\\",\\\"1200\\\"\";\n	 	sim900a_send_cmd(\"AT+CIPCLOSE=1\",\"CLOSE OK\",200);	//关闭连接\n		sim900a_send_cmd(\"AT+CIPSHUT\",\"SHUT OK\",200);		//关闭移动场景 \n		sim900a_send_cmd(\"AT+CSTT\",\"OK\",200);				//设置GPRS移动台类别为B,支持包交换和数据交换 \n		sim900a_send_cmd(\"AT+CIICR\",\"OK\",500);//设置PDP上下文,互联网接协议,接入点等信息\n		sim900a_send_cmd(\"AT+CIFSR\",\"OK\",200);					//附着GPRS业务\n		if(sim900a_send_cmd((u8*)p,\"OK\",500)==0)   return 0; \n		return 1;\n	}\n	return 1;\n} \n/////////////////////////////////////////////////////////////////////////////////////////////////////////// \n//0表示成功,表示主机已经接收到数据，节点接收状态未知\n//1表示没有发送成\n//向sim900a发送32位数据 \nu8 sim900a_send_data(u8 *data)\n{	\n\n    u8 i;\n    u8 reg=1;\n	//const char p[]=\"AT+HTTPPARA=\\\"URL\\\",\\\"http://2.smsfx.sinaapp.com/send.php?tel=18825174443&pwd=mima8565279&aim=18826484299&text=\";	 \n	const char p[]=\"AT+HTTPPARA=\\\"URL\\\",\\\"http://2.smsfx.sinaapp.com/send.php?tel=18825174443&pwd=mima8565279&aim=18825174443&text=\";	 \n	char str[34];\n    if(networkOption==GPRS)\n   	{\n	   		 for(i=0;i<32;i++)\n	    {\n		    str[i] =data[i]+48;\n	    }\n	    str[32]='\\\"';\n	    str[33]=0;\n	    sim900a_send_cmd(\"AT+HTTPTERM\",\"OK\",100);	\n	    sim900a_send_cmd(\"AT+SAPBR=3,1,\\\"APN\\\",\\\"CMNET\\\"\",\"OK\",100);	\n		// sim900a_send_cmd(\"AT+SAPBR=1,1\",\"OK\",100);					\n		sim900a_send_cmd(\"AT+HTTPINIT\",\"OK\",100);\n		sim900a_send_cmd(\"AT+HTTPPARA=\\\"CID\\\",1\",\"OK\",100);\n		sim900a_send1_cmd((u8*)p,\"ok\",10);\n	    sim900a_send_cmd((u8*)str,\"OK\",100);				 \n		if(sim900a_send_cmd(\"AT+HTTPACTION=0\",\"200\",2000)==0)   return 0; \n		return 1;\n   	}\n   	if(networkOption==ETHERNET)\n   	{\n   // sim900a_gprs_test();                     //sim9000a的初始化 	\n		if(sim900a_send_cmd(\"AT+CIPSEND\",\">\",300)==0)		//发送数据\n		{ \n		   u2_unm_printf(33,data);\n		   if(sim900a_send_cmd((u8*)0X1A,\"SEND OK\",300)==0)  //最长等待10s\n		   reg=0;\n		}\n		else \n		{\n		  sim900a_send_cmd((u8*)0X1B,0,0);	//ESC,取消发送\n		  reg=1;\n		}\n		  USART2_RX_STA=0; 	\n		  return reg;\n   	}\n   	return 1;\n}\n\nu8 sim900a_get_data(u8 *data)\n{\n    u8 buf2[32];\n    u8 i;\n	//  char data1[128];\n    char *strs=\"+CMTI: \\\"SM\\\"\";\n	u16 waittime=4000;  \n  \n   	if(networkOption==GPRS)\n   	{\n	   	  for(i=0;i<30;i++)\n	    {\n	    	buf2[i]=0;\n	    }\n		buf2[30]=1;  	buf2[31]=1; \n	    if(sim900a_send_data(buf2)==0)\n		{ \n			USART2_RX_STA=0;\n			while(--waittime)	//等待倒计时\n		    {\n				delay_ms(10);\n				if(USART2_RX_STA&0X8000)//接收到期待的应答结果\n				{\n	         USART2_RX_BUF[500]=0;//添加结束符\n				  USART2_RX_STA=0;//接收到期待的应答结果\n				  if(strstr((const char*)USART2_RX_BUF,(const char*)strs)) //判断不是第27条短信，如果是 的话才读取短息                   \n	            {\n	             sim900a_gsm_get(data);   //\n								return 0;		       \n		          }	 \n					}\n				}\n						\n			if(waittime==0)\n			{							  	\n				*(data+1)=1;			\n				*(data+0)=1;\n			}\n			sim900a_send_cmd(\"AT+CMGD=27\",\"OK\",200);	  //每次都删掉短信\n		  //  return 1;           \n		}	    	\n	   return 1;\n   	}\n   	if(networkOption==ETHERNET)\n   	{\n		waittime=800;  \n		buf2[30]=1;  	buf2[31]=1; \n	    if(sim900a_send_data(buf2)==0)\n		{ \n			while(--waittime)	//等待倒计时\n		    {\n				delay_ms(10);\n				if(USART2_RX_STA&0X8000)//接收到期待的应答结果\n				{\n			    	sim_at_response(0,data);	\n					return 0;\n				}\n			}	  \n	   }\n	   return 1;\n   	}\n   	return 1;\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////////////// \n//0表示成功,表示主机已经接收到数据，节点接收状态未知\n//1表示没有发送成\n//向sim900a发送32位数据\n// \nu8 sim900a_send_ctrl(u8 *data,u8 *data1)\n{\n    u8  sim_reg=1;\n	u16 waittime=4000; \n	\n    if(networkOption==GPRS)\n   	{\n	   	*(data+30)=0;\n		*(data+31)=0;\n		sim_reg=sim900a_send_data(data);\n		if(sim_reg==1)	 return sim_reg;\n		sim900a_send_cmd(\"AT+CMGD=27\",\"OK\",500);\n		USART2_RX_STA=0;\n		while(--waittime)	//等待倒计时\n		{\n			delay_ms(10);\n			if(USART2_RX_STA&0X8000)//接收到期待的应答结果\n			{\n				// sim_at_response(0,data1);//以太网	\n				sim900a_gsm_get(data1);//短信\n				*(data1+0)=0;\n				*(data1+1)=0;\n				return sim_reg;\n			}\n		}	  \n		if(waittime==0)\n		{							  	\n			*(data1+1)=1;			\n			*(data1+0)=1;\n		}\n	    return sim_reg;\n   	}\n   	if(networkOption==ETHERNET)\n   	{\n 		*(data+30)=0;\n		*(data+31)=0;\n		sim_reg=sim900a_send_data(data);\n		if(sim_reg==1)	 return sim_reg;\n		while(--waittime)	//等待倒计时\n		{\n			delay_ms(10);\n			if(USART2_RX_STA&0X8000)//接收到期待的应答结果\n			{\n				sim_at_response(0,data1);	\n				*(data+0)=0;\n				*(data+1)=0;\n				return sim_reg;\n			}\n		}	  \n		if(waittime==0)\n		{							  	\n			*(data+1)=1;			\n			*(data+0)=1;\n		}\n	    return sim_reg;\n   	}\n   	return 1;\n}\n/********************************************************************************************************\n*  Function: sim900a_set_time				                                                           \n*  Object: set time from the internet by sim900a \n*  Input: \n*  Output:                                  \n*  brief: none\n********************************************************************************************************/\nu8 sim900a_set_time(void)\n{\n	char time[17];//格式:yy/mm/dd,hh:mm:ss\n	u8 i;\n	sim900a_send_cmd(\"AT+CLTS=1\",\"OK\",200);//开启网络更新时间功能\n	if(sim900a_send_cmd(\"AT+CCLK?\",\"OK\",200)==0)//发送获取时间指令\n	{\n		memcpy(time,(const char*)(u8 *)strstr((const char*)USART2_RX_BUF,\"\\\"\")+1,17);//将从sim900a获取的时间字符串(17byte)复制至str\n	\n		for(i=0;i<17;i++)//由数字的ASCII字符转为对应的数字\n		{\n			time[i] -= 48;\n	 	}\n\n		RTC_Set(2000+time[0]*10+time[1],//年\n				time[3]*10+time[4],//月\n				time[6]*10+time[7],//日\n				time[9]*10+time[10],//时\n				time[12]*10+time[13],//分\n				time[15]*10+time[16]);//秒\n		return 0;\n	}\n	return 1;\n}\n\nvoid sim900a_test(void)\n{	\n	char str[27];\n	sim900a_send_cmd(\"ATE1\",\"OK\",200);\n	sim900a_send_cmd(\"AT+SAPBR=3,1,\\\"CONTYPE\\\",\\\"GPRS\\\"\",\"OK\",200);\n	sim900a_send_cmd(\"AT+SAPBR=3,1,\\\"APN\\\",\\\"CMWAP\\\"\",\"OK\",200);\n	sim900a_send_cmd(\"AT+SAPBR=1,1\",\"OK\",200);\n	sim900a_send_cmd(\"AT+SAPBR=2,1\",\"OK\",200);\n	sim900a_send_cmd(\"AT+CIPGSMLOC=1,1\",\"OK\",200);\n	memcpy(str,(const char*)USART2_RX_BUF,27);\n	LCD_DisASCString(0, 0, str, WHITE,1,RE_WRITE_BG);\n	memcpy(str,(const char*)USART2_RX_BUF+27,27);\n	LCD_DisASCString(16, 0, str, WHITE,1,RE_WRITE_BG);\n	memcpy(str,(const char*)USART2_RX_BUF+54,27);\n	LCD_DisASCString(32, 0, str, WHITE,1,RE_WRITE_BG);\n	while(1);\n}\n",
			"file": "HARDWARE/SIM900A/sim900a.c",
			"file_size": 11943,
			"file_write_time": 130543590943495732,
			"settings":
			{
				"buffer_size": 10720,
				"line_ending": "Windows",
				"scratch": true
			}
		},
		{
			"contents": "#include \"delay.h\"\n#include \"key.h\"\n#include \"sys.h\"\n#include \"usart.h\"	\n#include \"rtc.h\" \n#include \"prohead.h\"\n#include \"driver.h\" \n#include \"lcdlib.h\"\n#include \"setting.h\"\n#include \"Touch.h\"\n#include \"UI.h\"\n#include \"timer.h\"\n#include \"image.h\"\n#include <stdio.h>\n#include \"LD3320.h\"\n#include \"sim900a.h\"\n#include \"usart2.h\"\n#include \"remote.h\"\n#include \"network.h\"\n\n#define BACK_LIGHT PCout(7)\n#define ON 1\n#define OFF 0\n\n#define HOME 					0\n#define HOME_WITH_ICON			1\n#define VOICE_CTRL				2\n#define SETTING 				3\n#define REMOTE_CTRL				4\n\n\nvoid MUC_Init(void);\nint main(void)\n{	 \n	u8 keyValue = KEY_NULL;	\n	u8 IconTouchVal=TOUCH_NULL;\n	MUC_Init();\n	while(1)\n	{	\n		static u8 state = HOME; \n		keyValue = KEY_Scan();		\n		if(keyValue==(TWO_HIT 2))\n		{\n			BACK_LIGHT=!BACK_LIGHT;\n		}\n		if(keyValue==(LONG_PERIOD 2))\n		{\n			state = VOICE_CTRL;\n			Load_voice_Ctrl_Pannel();\n		}	\n		switch(state)\n		{\n			case HOME:\n				Display_Time();\n				Display_Date();\n				if(keyValue==(ONE_HIT 2))\n				{\n					state = HOME_WITH_ICON;\n				}\n				break;\n			case HOME_WITH_ICON:\n				Display_Time();\n				if(flagShowIcons == RESET)\n				{\n					Show_Iocns();\n					flagShowIcons=SET;\n				}\n				if(keyValue==(ONE_HIT 2))\n				{\n					UNLOAD_ICONS;\n					flagShowIcons=RESET;\n					state = HOME;\n				}\n\n				IconTouchVal=TOUCH_Scan(Touch_Icons);\n				if(IconTouchVal!=TOUCH_NULL)\n				{\n					switch (IconTouchVal)\n					{\n						case 1 :\n							if(flagIconFdback==RESET)\n							{\n								 Icon_Touch_fdback(110,23,42,3,gImage_voice,RED,LIGHTBLUE);\n								flagIconFdback=SET;\n							}\n							break;\n						case CLICK 1 :\n							delay_ms(200);\n							flagIconFdback=RESET;\n							UNLOAD_ICONS;\n							Load_voice_Ctrl_Pannel();\n							state=VOICE_CTRL;\n							break;\n						case 2 :\n							if(flagIconFdback==RESET)\n							{\n								Icon_Touch_fdback(110,90,42,3,gImage_remote,RED,LIGHTBLUE);\n								flagIconFdback=SET;\n							}\n							break;\n						case CLICK 2 :\n							delay_ms(200);\n							flagIconFdback=RESET;\n							UNLOAD_ICONS;\n							Load_Ctrl_Pannel();\n							state=REMOTE_CTRL;\n							break;	\n						case 3 :\n							if(flagIconFdback==RESET)\n							{\n								Icon_Touch_fdback(110,155,42,3,gImage_setting,BLACK,LIGHTBLUE);\n								flagIconFdback=SET;\n							}\n							break;\n						case CLICK 3 :\n							delay_ms(200);\n							flagIconFdback=RESET;\n							UNLOAD_ICONS;\n							UNLOAD_CLOCK;\n							Load_Keyborad();\n							state=SETTING;\n							break;	\n						default:break;\n					}\n				}\n				break;\n			case VOICE_CTRL:\n				Voice_Ctrl();\n				Load_BGImage();\n				state=HOME_WITH_ICON;\n				break;\n			case SETTING:\n				Ctrl_Setting_Touch_Handler();\n				Load_BGImage();\n				state=HOME_WITH_ICON;\n				break;\n			case REMOTE_CTRL:\n				Ctrl_Pannel_Touch_Handler();\n				Load_BGImage();\n				state=HOME_WITH_ICON;\n				break;	\n			default:break;	\n		}\n	}\n}\n\nvoid MUC_Init()\n{ 	\n	delay_init();	    \n	KEY_Init();         \n	NVIC_Configuration(); \n	TIM3_Int_Init(9,7199);\n	uart_init(9600);	\n    USART2_Init(9600);	\n	RTC_Init();	  \n	Driver_MCU_Init();\n	LCD_Init();	\n	Driver_LcdBacklight(True);	 \n	LCD_ClrScr(BLACK);	\n	Load_BGImage();\n	// Display_Time();\n\n	TOUCH_init();	\n	LD3320_init();\n\n	\n	ChooseNetwork();\n	delay_ms(1000);\n	UNLOAD_NETWORK_CHOOSE_BT;\n	Show_Ch_Message_Centre(\"正在初始化网络\");\n	\n	if(sim900a_gprs_init()!=0)\n	{\n		CLEAR_MESSAGE;\n		Show_Ch_Message_Centre(\"初始化网络失败，请重新上电\");\n		while(1);\n	}\n	sim900a_set_time();\n	CLEAR_MESSAGE;\n	TimeShowingFlag=RESET;\n\n}\n\n",
			"file": "USER/main.c",
			"file_size": 3608,
			"file_write_time": 130547753442248735,
			"settings":
			{
				"buffer_size": 3405,
				"line_ending": "Windows",
				"scratch": true
			}
		},
		{
			"contents": "#include \"delay.h\"  \n#include \"sys.h\"\n#include \"usart.h\"\n#include \"stm32f10x_gpio.h\"  \n#include \"timer.h\"\n#include \"UI.h\"\n#include \"sim900a.h\"\n#include \"stm32f10x.h\"\n#include \"prohead.h\"\n#include \"driver.h\" \n#include \"lcdlib.h\"\n#include \"Touch.h\"\n#include \"image.h\"\n#include \"remote.h\"\n#include \"key.h\"\n#include <stdio.h>\n\n#define BLOCK_ON_COLOR			WHITE\n#define BLOCK_OFF_COLOR			LIGHTBLUE\n#define BLOCK_FRESH_COLOR			GRAY\n\n#define BORDER_ON_COLOR			LIGHTBLUE\n#define BORDER_OFF_COLOR		WHITE\n\n#define FONT_COLOR_ON			LIGHTBLUE\n#define FONT_COLOR_OFF			WHITE\n\n#define AIR_CONDITIONER			0\n#define LIVING_ROOM_LIGHT 		1\n#define BEDROOM_LIGHT			2\n#define DOOR 					3\n#define WINDOW					5\n\n#define SUCCEED 0\n#define FAILED  1\n#define ON 1\n#define OFF 0\n\n#define SHIFT_TIME 1000\n\nextern u8 TXdatabuf[32];     \nextern u8 RXdatabuf[32]; \nbool block_state[9]={OFF,OFF,OFF,OFF,OFF,OFF,OFF,OFF,OFF};\n\nchar temperature[]=\"  \";\nchar humidity[]=\"  \";\n\nvoid Fill_Block_Color(u8 order,u16 color)\n{\n	u8 i,j;\n	i=order/3;\n	j=order%3;\n	LCD_DisARectangular(5+i*57,5+j*71,(i+1)*57,(j+1)*71,color);\n	\n}\nvoid Ctrl_Pannel_Touch_FdBack(u8 order,u16 color)\n{\n	u8 i,j;\n	i=order/3;\n	j=order%3;\n	LCD_DisAWideBorder(5+i*57,5+j*71,(i+1)*57,(j+1)*71,3,color);\n}\nvoid Ctrl_Pannel_Touch_Release_FdBack(u8 order,u16 color)\n{\n	u8 i,j;\n	i=order/3;\n	j=order%3;\n	LCD_DisAWideBorder(5+i*57,5+j*71,(i+1)*57,(j+1)*71,3,color);\n}\nvoid Reset_Txdatabuf(void)\n{\n	u8 i=0;\n	for(i=0;i<=6;i++)\n	{\n		TXdatabuf[i]=2;//2为无用控制信息，给接收端作判断用\n	}\n}\n\nvoid refresh(void)\n{\n	u16 temp;\n\n	if(sim900a_get_data(RXdatabuf)==SUCCEED)\n	{\n		if(RXdatabuf[2]!=2)block_state[AIR_CONDITIONER]=RXdatabuf[2];\n		if(RXdatabuf[3]!=2)block_state[LIVING_ROOM_LIGHT]=RXdatabuf[3];\n		if(RXdatabuf[4]!=2)block_state[BEDROOM_LIGHT]=RXdatabuf[4];\n		if(RXdatabuf[5]!=2)block_state[DOOR]=RXdatabuf[5];\n		if(RXdatabuf[6]!=2)block_state[WINDOW]=RXdatabuf[6];\n\n		//重新显示更新的面板\n		if(block_state[AIR_CONDITIONER]==OFF)\n		{\n			Fill_Block_Color(0,BLOCK_OFF_COLOR);\n			LCD_DisGB2312String16x16(22,22,\"空调\",WHITE,LIGHTBLUE);\n		}\n		else\n		{\n			Fill_Block_Color(0,BLOCK_ON_COLOR);\n			LCD_DisGB2312String16x16(22,22,\"空调\",LIGHTBLUE,BLOCK_ON_COLOR);\n		}\n\n		if(block_state[LIVING_ROOM_LIGHT]==OFF)\n		{\n			Fill_Block_Color(1,BLOCK_OFF_COLOR);\n			LCD_DisGB2312String16x16(22,22+71-8,\"客厅灯\",WHITE,LIGHTBLUE);\n		}\n		else\n		{\n			Fill_Block_Color(1,BLOCK_ON_COLOR);\n			LCD_DisGB2312String16x16(22,22+71-8,\"客厅灯\",LIGHTBLUE,BLOCK_ON_COLOR);\n		}\n		\n		if(block_state[BEDROOM_LIGHT]==OFF)\n		{\n			Fill_Block_Color(2,BLOCK_OFF_COLOR);\n			LCD_DisGB2312String16x16(22,22+71-8+71,\"卧室灯\",WHITE,LIGHTBLUE);\n		}\n		else\n		{\n			Fill_Block_Color(2,BLOCK_ON_COLOR);\n			LCD_DisGB2312String16x16(22,22+71-8+71,\"卧室灯\",LIGHTBLUE,BLOCK_ON_COLOR);\n		}\n		\n		if(block_state[DOOR]==OFF)\n		{\n			Fill_Block_Color(3,BLOCK_OFF_COLOR);\n			LCD_DisGB2312String16x16(22+57,30,\"门\",WHITE,LIGHTBLUE);\n		}\n		else\n		{\n			Fill_Block_Color(3,BLOCK_ON_COLOR);\n			LCD_DisGB2312String16x16(22+57,30,\"门\",LIGHTBLUE,BLOCK_ON_COLOR);\n		}\n		if(block_state[WINDOW]==OFF)\n		{\n			Fill_Block_Color(5,BLOCK_OFF_COLOR);\n			LCD_DisGB2312String16x16(22+57,30+142,\"窗\",WHITE,LIGHTBLUE);\n		}\n		else\n		{\n			Fill_Block_Color(5,BLOCK_ON_COLOR);\n			LCD_DisGB2312String16x16(22+57,30+142,\"窗\",LIGHTBLUE,BLOCK_ON_COLOR);\n		}\n\n		//此处显示温湿度更新\n		if(RXdatabuf[6]!=2)\n		{\n			temp=(u16)RXdatabuf[7];\n			temp <<=8;\n			temp = (u16)(temp + RXdatabuf[8])/10;\n			sprintf(temperature,\"%02u\",temp);\n\n			temp=(u16)RXdatabuf[9];\n			temp <<=8;\n			temp = (u16)(temp + RXdatabuf[10])/10;\n			sprintf(humidity,\"%02u\",temp);\n\n			LCD_DisARectangular(145,45,145+16,70,LIGHTBLUE);\n			LCD_DisASCString(145,45,temperature,WHITE,2,KEEP_BG);\n		\n			LCD_DisARectangular(145,45+71,145+16,70+71,LIGHTBLUE);\n			LCD_DisASCString(145,45+71,humidity,WHITE,2,KEEP_BG);\n		}\n\n		//\n		LCD_DisGB2312String16x16(22+57,22+71-16,\"更新完成\",WHITE,GRAY);\n		delay_ms(800);\n		Fill_Block_Color(4,LIGHTBLUE);\n		LCD_DisGB2312String16x16(22+57,22+71,\"更新\",WHITE,LIGHTBLUE);\n\n	}\n	else\n	{\n		LCD_DisGB2312String16x16(22+57,22+71-16,\"更新失败\",WHITE,GRAY);\n		delay_ms(1500);\n		Fill_Block_Color(4,LIGHTBLUE);\n		LCD_DisGB2312String16x16(22+57,22+71,\"更新\",WHITE,LIGHTBLUE);\n	}\n}\n\nvoid Load_Ctrl_Pannel(void)\n{\n	LCD_WriteReg(0X03);\n	#if (LCD_DIRECT == 1)	\n		LCD_WriteData(0X1008);		\n	#else\n		LCD_WriteData(0X1030);      //vertical\n	#endif\n	LCD_ClrScr(LIGHTBLUE);\n	LCD_WriteReg(0X03);\n	#if (LCD_DIRECT == 1)	\n		LCD_WriteData(0X1038);		//horizontal\n	#else\n		LCD_WriteData(0X1030);      //vertical\n	#endif\n\n	TimeShowingFlag=RESET;\n	flagShowIcons=RESET;\n	DateShowingFlag=RESET;\n\n	LCD_DisAWideBorder(0,0,175,219,5,BLACK);\n	LCD_DisLines(57,0,1,220,4,BLACK);\n	LCD_DisLines(114,0,1,220,4,BLACK);\n	LCD_DisLines(0,71,2,176,4,BLACK);\n	LCD_DisLines(0,142,2,176,4,BLACK);\n	LCD_DisLines(0,213,2,176,2,BLACK);\n\n\n	//载入面板，各方块的状态维持最近一次更新的状态\n	if(block_state[AIR_CONDITIONER]==OFF)\n	{\n		LCD_DisGB2312String16x16(22,22,\"空调\",WHITE,LIGHTBLUE);\n	}\n	else\n	{\n		Fill_Block_Color(0,BLOCK_ON_COLOR);\n		LCD_DisGB2312String16x16(22,22,\"空调\",LIGHTBLUE,BLOCK_ON_COLOR);\n	}\n\n	if(block_state[LIVING_ROOM_LIGHT]==OFF)\n	{\n		LCD_DisGB2312String16x16(22,22+71-8,\"客厅灯\",WHITE,LIGHTBLUE);\n	}\n	else\n	{\n		Fill_Block_Color(1,BLOCK_ON_COLOR);\n		LCD_DisGB2312String16x16(22,22+71-8,\"客厅灯\",LIGHTBLUE,BLOCK_ON_COLOR);\n	}\n	\n	if(block_state[BEDROOM_LIGHT]==OFF)\n	{\n		LCD_DisGB2312String16x16(22,22+71-8+71,\"卧室灯\",WHITE,LIGHTBLUE);\n	}\n	else\n	{\n		Fill_Block_Color(2,BLOCK_ON_COLOR);\n		LCD_DisGB2312String16x16(22,22+71-8+71,\"卧室灯\",LIGHTBLUE,BLOCK_ON_COLOR);\n	}\n	\n	if(block_state[DOOR]==OFF)\n	{\n		LCD_DisGB2312String16x16(22+57,30,\"门\",WHITE,LIGHTBLUE);\n	}\n	else\n	{\n		Fill_Block_Color(3,BLOCK_ON_COLOR);\n		LCD_DisGB2312String16x16(22+57,30,\"门\",LIGHTBLUE,BLOCK_ON_COLOR);\n	}\n	if(block_state[WINDOW]==OFF)\n	{\n		LCD_DisGB2312String16x16(22+57,30+142,\"窗\",WHITE,LIGHTBLUE);\n	}\n	else\n	{\n		Fill_Block_Color(5,BLOCK_ON_COLOR);\n		LCD_DisGB2312String16x16(22+57,30+142,\"窗\",LIGHTBLUE,BLOCK_ON_COLOR);\n	}\n	Fill_Block_Color(4,GRAY);	\n	LCD_DisGB2312String16x16(22+57,22+71-16,\"正在更新\",WHITE,GRAY);\n\n	LCD_DisGB2312String16x16(10+57+57,10,\"温度\",WHITE,LIGHTBLUE);\n	\n	LCD_DisASCString(145,45,temperature,WHITE,2,KEEP_BG);\n	\n	LCD_DisGB2312String16x16(10+57+57,10+71,\"湿度\",WHITE,LIGHTBLUE);\n	\n	LCD_DisASCString(145,45+71,humidity,WHITE,2,KEEP_BG);\n\n	LCD_DisGB2312String16x16(22+57+57,24+142,\"返回\",WHITE,LIGHTBLUE);\n\n 	//更新设备状态\n	refresh();\n\n}\n\nvoid Ctrl_Pannel_Touch_Handler(void)\n{\n	u8 TouchValTemp;\n	u8 keyValue;\n	u8 block;\n	u16 temp;\n	u8 i;\n	while(1)\n	{\n		keyValue=KEY_Scan();\n		if(keyValue==(ONE_HIT 2))\n		{\n			return;\n		}\n\n		TouchValTemp=TOUCH_Scan(Touch_Ctrl_Pannel);//输出值为0－8或上相应的标志\n		if(TouchValTemp!=TOUCH_NULL)\n		{\n			if(TouchValTemp<9)\n			{\n				\n				if(block_state[TouchValTemp]==OFF)//根据区块当前状态\n				{\n					Ctrl_Pannel_Touch_FdBack(TouchValTemp,WHITE);\n				}\n				else\n				{\n					Ctrl_Pannel_Touch_FdBack(TouchValTemp,LIGHTBLUE);\n				}\n			}\n			else\n			{\n				block = TouchValTemp & 0x0f;//block 取值为0~8\n				if(block<8)\n				{\n					Fill_Block_Color(block,BLOCK_FRESH_COLOR);\n				}\n				switch(block)\n				{\n\n					case 0:\n						Reset_Txdatabuf();\n\n						if(block_state[AIR_CONDITIONER]==ON)\n						{\n							TXdatabuf[2]=OFF;\n							LCD_DisGB2312String16x16(22,22-16,\"正在关闭\",WHITE,BLOCK_FRESH_COLOR);\n						}\n						else\n						{\n							TXdatabuf[2]=ON;\n							LCD_DisGB2312String16x16(22,22-16,\"正在打开\",WHITE,BLOCK_FRESH_COLOR);\n						}\n\n						if(sim900a_send_ctrl(TXdatabuf,RXdatabuf)==SUCCEED)//发送成功\n						{\n							if(RXdatabuf[0]==SUCCEED)//返回信息成功\n							{\n								if(TXdatabuf[2]==RXdatabuf[2])//发送控制信息与对应返回状态信息一致\n								{\n									if(block_state[AIR_CONDITIONER]==ON)\n									{\n										block_state[AIR_CONDITIONER]=OFF;\n										Fill_Block_Color(block,BLOCK_OFF_COLOR);\n										LCD_DisGB2312String16x16(22,22,\"空调\",FONT_COLOR_OFF,BLOCK_OFF_COLOR);\n									}\n									else\n									{\n										block_state[AIR_CONDITIONER]=ON;\n										Fill_Block_Color(block,BLOCK_ON_COLOR);\n										LCD_DisGB2312String16x16(22,22,\"空调\",FONT_COLOR_ON,BLOCK_ON_COLOR);\n									}\n								}\n								else//操作失败\n								{\n									LCD_DisGB2312String16x16(22,22-16,\"操作失败\",WHITE,BLOCK_FRESH_COLOR);\n									delay_ms(SHIFT_TIME);\n									if(block_state[AIR_CONDITIONER]==ON)\n									{\n										Fill_Block_Color(block,BLOCK_ON_COLOR);\n										LCD_DisGB2312String16x16(22,22,\"空调\",FONT_COLOR_ON,BLOCK_ON_COLOR);\n									}\n									else\n									{\n										Fill_Block_Color(block,BLOCK_OFF_COLOR);\n										LCD_DisGB2312String16x16(22,22,\"空调\",FONT_COLOR_OFF,BLOCK_OFF_COLOR);\n									}\n								}\n							}\n							else//连接失败\n							{\n								LCD_DisGB2312String16x16(22,22-16,\"连接失败\",WHITE,BLOCK_FRESH_COLOR);\n								delay_ms(SHIFT_TIME);\n								if(block_state[AIR_CONDITIONER]==ON)\n								{\n									Fill_Block_Color(block,BLOCK_ON_COLOR);\n									LCD_DisGB2312String16x16(22,22,\"空调\",FONT_COLOR_ON,BLOCK_ON_COLOR);\n								}\n								else\n								{\n									Fill_Block_Color(block,BLOCK_OFF_COLOR);\n									LCD_DisGB2312String16x16(22,22,\"空调\",FONT_COLOR_OFF,BLOCK_OFF_COLOR);\n								}\n							}\n						}\n						else//发送失败\n						{\n							LCD_DisGB2312String16x16(22,22-16,\"发送失败\",WHITE,BLOCK_FRESH_COLOR);\n							delay_ms(SHIFT_TIME);\n							if(block_state[AIR_CONDITIONER]==ON)\n							{\n								Fill_Block_Color(block,BLOCK_ON_COLOR);\n								LCD_DisGB2312String16x16(22,22,\"空调\",FONT_COLOR_ON,BLOCK_ON_COLOR);\n							}\n							else\n							{\n								Fill_Block_Color(block,BLOCK_OFF_COLOR);\n								LCD_DisGB2312String16x16(22,22,\"空调\",FONT_COLOR_OFF,BLOCK_OFF_COLOR);\n							}\n						}\n						break;\n\n					case 1:\n						Reset_Txdatabuf();\n\n						if(block_state[LIVING_ROOM_LIGHT]==ON) \n						{\n							TXdatabuf[3]=OFF;\n							LCD_DisGB2312String16x16(22,22-16+71,\"正在关闭\",WHITE,BLOCK_FRESH_COLOR);\n						}\n						else\n						{\n							TXdatabuf[3]=ON;\n							LCD_DisGB2312String16x16(22,22-16+71,\"正在打开\",WHITE,BLOCK_FRESH_COLOR);\n						}\n\n						if(sim900a_send_ctrl(TXdatabuf,RXdatabuf)==SUCCEED)//发送成功\n						{\n							if(RXdatabuf[0]==SUCCEED)//返回信息成功\n							{\n								if(TXdatabuf[3]==RXdatabuf[3])//发送控制信息与对应返回状态信息一致\n								{\n									if(block_state[LIVING_ROOM_LIGHT]==ON)\n									{\n										block_state[LIVING_ROOM_LIGHT]=OFF;\n										Fill_Block_Color(block,BLOCK_OFF_COLOR);\n										LCD_DisGB2312String16x16(22,22+71-8,\"客厅灯\",FONT_COLOR_OFF,BLOCK_OFF_COLOR);\n									}\n									else\n									{\n										block_state[LIVING_ROOM_LIGHT]=ON;\n										Fill_Block_Color(block,BLOCK_ON_COLOR);\n										LCD_DisGB2312String16x16(22,22+71-8,\"客厅灯\",FONT_COLOR_ON,BLOCK_ON_COLOR);\n									}\n								}\n								else//操作失败\n								{\n									LCD_DisGB2312String16x16(22,22-16+71,\"操作失败\",WHITE,BLOCK_FRESH_COLOR);\n									delay_ms(SHIFT_TIME);\n									if(block_state[LIVING_ROOM_LIGHT]==ON)\n									{\n										Fill_Block_Color(block,BLOCK_ON_COLOR);\n										LCD_DisGB2312String16x16(22,22+71-8,\"客厅灯\",FONT_COLOR_ON,BLOCK_ON_COLOR);\n									}\n									else\n									{\n										Fill_Block_Color(block,BLOCK_OFF_COLOR);\n										LCD_DisGB2312String16x16(22,22+71-8,\"客厅灯\",FONT_COLOR_OFF,BLOCK_OFF_COLOR);\n									}\n								}\n							}\n							else//连接失败\n							{\n								LCD_DisGB2312String16x16(22,22-16+71,\"连接失败\",WHITE,BLOCK_FRESH_COLOR);\n								delay_ms(SHIFT_TIME);\n								if(block_state[LIVING_ROOM_LIGHT]==ON)\n								{\n									Fill_Block_Color(block,BLOCK_ON_COLOR);\n									LCD_DisGB2312String16x16(22,22+71-8,\"客厅灯\",FONT_COLOR_ON,BLOCK_ON_COLOR);\n								}\n								else\n								{\n									Fill_Block_Color(block,BLOCK_OFF_COLOR);\n									LCD_DisGB2312String16x16(22,22+71-8,\"客厅灯\",FONT_COLOR_OFF,BLOCK_OFF_COLOR);\n								}\n							}\n						}\n						else//发送失败\n						{\n							LCD_DisGB2312String16x16(22,22-16+71,\"发送失败\",WHITE,BLOCK_FRESH_COLOR);\n							delay_ms(SHIFT_TIME);\n							if(block_state[LIVING_ROOM_LIGHT]==ON)\n							{\n								Fill_Block_Color(block,BLOCK_ON_COLOR);\n								LCD_DisGB2312String16x16(22,22+71-8,\"客厅灯\",FONT_COLOR_ON,BLOCK_ON_COLOR);\n							}\n							else\n							{\n								Fill_Block_Color(block,BLOCK_OFF_COLOR);\n								LCD_DisGB2312String16x16(22,22+71-8,\"客厅灯\",FONT_COLOR_OFF,BLOCK_OFF_COLOR);\n							}\n						}\n						break;\n\n					case 2:\n						Reset_Txdatabuf();\n\n						if(block_state[BEDROOM_LIGHT]==ON) \n						{\n							TXdatabuf[4]=OFF;\n							LCD_DisGB2312String16x16(22,22-16+142,\"正在关闭\",WHITE,BLOCK_FRESH_COLOR);\n						}\n						else\n						{\n							TXdatabuf[4]=ON;\n							LCD_DisGB2312String16x16(22,22-16+142,\"正在打开\",WHITE,BLOCK_FRESH_COLOR);\n						}\n\n						if(sim900a_send_ctrl(TXdatabuf,RXdatabuf)==SUCCEED)//发送成功\n						{\n							if(RXdatabuf[0]==SUCCEED)//返回信息成功\n							{\n								if(TXdatabuf[4]==RXdatabuf[4])//发送控制信息与对应返回状态信息一致\n								{\n									if(block_state[BEDROOM_LIGHT]==ON)\n									{\n										block_state[BEDROOM_LIGHT]=OFF;\n										Fill_Block_Color(block,BLOCK_OFF_COLOR);\n										LCD_DisGB2312String16x16(22,22+142-8,\"卧室灯\",FONT_COLOR_OFF,BLOCK_OFF_COLOR);\n									}\n									else\n									{\n										block_state[BEDROOM_LIGHT]=ON;\n										Fill_Block_Color(block,BLOCK_ON_COLOR);\n										LCD_DisGB2312String16x16(22,22+142-8,\"卧室灯\",FONT_COLOR_ON,BLOCK_ON_COLOR);\n									}\n								}\n								else//操作失败\n								{\n									LCD_DisGB2312String16x16(22,22-16+142,\"操作失败\",WHITE,BLOCK_FRESH_COLOR);\n									delay_ms(SHIFT_TIME);\n									if(block_state[BEDROOM_LIGHT]==ON)\n									{\n										Fill_Block_Color(block,BLOCK_ON_COLOR);\n										LCD_DisGB2312String16x16(22,22+142-8,\"卧室灯\",FONT_COLOR_ON,BLOCK_ON_COLOR);\n									}\n									else\n									{\n										Fill_Block_Color(block,BLOCK_OFF_COLOR);\n										LCD_DisGB2312String16x16(22,22+142-8,\"卧室灯\",FONT_COLOR_OFF,BLOCK_OFF_COLOR);\n									}\n								}\n							}\n							else//连接失败\n							{\n								LCD_DisGB2312String16x16(22,22-16+142,\"连接失败\",WHITE,BLOCK_FRESH_COLOR);\n								delay_ms(SHIFT_TIME);\n								if(block_state[BEDROOM_LIGHT]==ON)\n								{\n									Fill_Block_Color(block,BLOCK_ON_COLOR);\n									LCD_DisGB2312String16x16(22,22+142-8,\"卧室灯\",FONT_COLOR_ON,BLOCK_ON_COLOR);\n								}\n								else\n								{\n									Fill_Block_Color(block,BLOCK_OFF_COLOR);\n									LCD_DisGB2312String16x16(22,22+142-8,\"卧室灯\",FONT_COLOR_OFF,BLOCK_OFF_COLOR);\n								}\n							}\n						}\n						else//发送失败\n						{\n							LCD_DisGB2312String16x16(22,22-16+142,\"发送失败\",WHITE,BLOCK_FRESH_COLOR);\n							delay_ms(SHIFT_TIME);\n							if(block_state[BEDROOM_LIGHT]==ON)\n							{\n								Fill_Block_Color(block,BLOCK_ON_COLOR);\n								LCD_DisGB2312String16x16(22,22+142-8,\"卧室灯\",FONT_COLOR_ON,BLOCK_ON_COLOR);\n							}\n							else\n							{\n								Fill_Block_Color(block,BLOCK_OFF_COLOR);\n								LCD_DisGB2312String16x16(22,22+142-8,\"卧室灯\",FONT_COLOR_OFF,BLOCK_OFF_COLOR);\n							}\n						}\n						break;\n					case 3:\n												Reset_Txdatabuf();\n\n						if(block_state[DOOR]==ON)\n						{\n							TXdatabuf[5]=OFF;\n							LCD_DisGB2312String16x16(22+57,22-16,\"正在关闭\",WHITE,BLOCK_FRESH_COLOR);\n						}\n						else\n						{\n							TXdatabuf[5]=ON;\n							LCD_DisGB2312String16x16(22+57,22-16,\"正在打开\",WHITE,BLOCK_FRESH_COLOR);\n						}\n\n						if(sim900a_send_ctrl(TXdatabuf,RXdatabuf)==SUCCEED)//发送成功\n						{\n							if(RXdatabuf[0]==SUCCEED)//返回信息成功\n							{\n								if(TXdatabuf[5]==RXdatabuf[5])//发送控制信息与对应返回状态信息一致\n								{\n									if(block_state[DOOR]==ON)\n									{\n										block_state[DOOR]=OFF;\n										Fill_Block_Color(block,BLOCK_OFF_COLOR);\n										LCD_DisGB2312String16x16(22+57,30,\"门\",FONT_COLOR_OFF,BLOCK_OFF_COLOR);\n									}\n									else\n									{\n										block_state[DOOR]=ON;\n										Fill_Block_Color(block,BLOCK_ON_COLOR);\n										LCD_DisGB2312String16x16(22+57,30,\"门\",FONT_COLOR_ON,BLOCK_ON_COLOR);\n									}\n								}\n								else//操作失败\n								{\n									LCD_DisGB2312String16x16(22+57,22-16,\"操作失败\",WHITE,BLOCK_FRESH_COLOR);\n									delay_ms(SHIFT_TIME);\n									if(block_state[DOOR]==ON)\n									{\n										Fill_Block_Color(block,BLOCK_ON_COLOR);\n										LCD_DisGB2312String16x16(22+57,30,\"门\",FONT_COLOR_ON,BLOCK_ON_COLOR);\n									}\n									else\n									{\n										Fill_Block_Color(block,BLOCK_OFF_COLOR);\n										LCD_DisGB2312String16x16(22+57,30,\"门\",FONT_COLOR_OFF,BLOCK_OFF_COLOR);\n									}\n								}\n							}\n							else//连接失败\n							{\n								LCD_DisGB2312String16x16(22+57,22-16,\"连接失败\",WHITE,BLOCK_FRESH_COLOR);\n								delay_ms(SHIFT_TIME);\n								if(block_state[DOOR]==ON)\n								{\n									Fill_Block_Color(block,BLOCK_ON_COLOR);\n									LCD_DisGB2312String16x16(22+57,30,\"门\",FONT_COLOR_ON,BLOCK_ON_COLOR);\n								}\n								else\n								{\n									Fill_Block_Color(block,BLOCK_OFF_COLOR);\n									LCD_DisGB2312String16x16(22+57,30,\"门\",FONT_COLOR_OFF,BLOCK_OFF_COLOR);\n								}\n							}\n						}\n						else//发送失败\n						{\n							LCD_DisGB2312String16x16(22+57,22-16,\"发送失败\",WHITE,BLOCK_FRESH_COLOR);\n							delay_ms(SHIFT_TIME);\n							if(block_state[DOOR]==ON)\n							{\n								Fill_Block_Color(block,BLOCK_ON_COLOR);\n								LCD_DisGB2312String16x16(22+57,30,\"门\",FONT_COLOR_ON,BLOCK_ON_COLOR);\n							}\n							else\n							{\n								Fill_Block_Color(block,BLOCK_OFF_COLOR);\n								LCD_DisGB2312String16x16(22+57,30,\"门\",FONT_COLOR_OFF,BLOCK_OFF_COLOR);\n							}\n						}\n						break;\n					case 4:\n						LCD_DisGB2312String16x16(22+57,22+71-16,\"正在更新\",WHITE,BLOCK_FRESH_COLOR);	\n						refresh();\n						 break;	 \n					case 5:\n						Reset_Txdatabuf();\n\n						if(block_state[WINDOW]==ON)\n						{\n							TXdatabuf[6]=OFF;\n							LCD_DisGB2312String16x16(22+57,22-16+142,\"正在关闭\",WHITE,BLOCK_FRESH_COLOR);\n						}\n						else\n						{\n							TXdatabuf[6]=ON;\n							LCD_DisGB2312String16x16(22+57,22-16+142,\"正在打开\",WHITE,BLOCK_FRESH_COLOR);\n						}\n\n						if(sim900a_send_ctrl(TXdatabuf,RXdatabuf)==SUCCEED)//发送成功\n						{\n							if(RXdatabuf[0]==SUCCEED)//返回信息成功\n							{\n								if(TXdatabuf[6]==RXdatabuf[6])//发送控制信息与对应返回状态信息一致\n								{\n									if(block_state[WINDOW]==ON)\n									{\n										block_state[WINDOW]=OFF;\n										Fill_Block_Color(block,BLOCK_OFF_COLOR);\n										LCD_DisGB2312String16x16(22+57,30+142,\"窗\",FONT_COLOR_OFF,BLOCK_OFF_COLOR);\n									}\n									else\n									{\n										block_state[WINDOW]=ON;\n										Fill_Block_Color(block,BLOCK_ON_COLOR);\n										LCD_DisGB2312String16x16(22+57,30+142,\"窗\",FONT_COLOR_ON,BLOCK_ON_COLOR);\n									}\n								}\n								else//操作失败\n								{\n									LCD_DisGB2312String16x16(22+57,22-16+142,\"操作失败\",WHITE,BLOCK_FRESH_COLOR);\n									delay_ms(SHIFT_TIME);\n									if(block_state[WINDOW]==ON)\n									{\n										Fill_Block_Color(block,BLOCK_ON_COLOR);\n										LCD_DisGB2312String16x16(22+57,30+142,\"窗\",FONT_COLOR_ON,BLOCK_ON_COLOR);\n									}\n									else\n									{\n										Fill_Block_Color(block,BLOCK_OFF_COLOR);\n										LCD_DisGB2312String16x16(22+57,30+142,\"窗\",FONT_COLOR_OFF,BLOCK_OFF_COLOR);\n									}\n								}\n							}\n							else//连接失败\n							{\n								LCD_DisGB2312String16x16(22+57,22-16+142,\"连接失败\",WHITE,BLOCK_FRESH_COLOR);\n								delay_ms(SHIFT_TIME);\n								if(block_state[WINDOW]==ON)\n								{\n									Fill_Block_Color(block,BLOCK_ON_COLOR);\n									LCD_DisGB2312String16x16(22+57,30+142,\"窗\",FONT_COLOR_ON,BLOCK_ON_COLOR);\n								}\n								else\n								{\n									Fill_Block_Color(block,BLOCK_OFF_COLOR);\n									LCD_DisGB2312String16x16(22+57,30+142,\"窗\",FONT_COLOR_OFF,BLOCK_OFF_COLOR);\n								}\n							}\n						}\n						else//发送失败\n						{\n							LCD_DisGB2312String16x16(22+57,22-16+142,\"发送失败\",WHITE,BLOCK_FRESH_COLOR);\n							delay_ms(SHIFT_TIME);\n							if(block_state[WINDOW]==ON)\n							{\n								Fill_Block_Color(block,BLOCK_ON_COLOR);\n								LCD_DisGB2312String16x16(22+57,30+142,\"窗\",FONT_COLOR_ON,BLOCK_ON_COLOR);\n							}\n							else\n							{\n								Fill_Block_Color(block,BLOCK_OFF_COLOR);\n								LCD_DisGB2312String16x16(22+57,30+142,\"窗\",FONT_COLOR_OFF,BLOCK_OFF_COLOR);\n							}\n						}\n						break;\n					case 6:\n						LCD_DisGB2312String16x16(10+57+57,10,\"温度\",WHITE,BLOCK_FRESH_COLOR);\n						LCD_DisGB2312String16x16(150,14+10,\"更新中\",WHITE,BLOCK_FRESH_COLOR);\n						if(sim900a_get_data(RXdatabuf)==SUCCEED)\n						{\n							if(RXdatabuf[0]==SUCCEED)\n							{\n								if(RXdatabuf[6]!=2)\n								{\n									LCD_DisGB2312String16x16(150,10,\"更新成功\",WHITE,BLOCK_FRESH_COLOR);\n									delay_ms(SHIFT_TIME);\n									temp=(u16)RXdatabuf[7];\n									temp <<=8;\n									temp = (u16)(temp + RXdatabuf[8])/10;\n									sprintf(temperature,\"%02u\",temp);\n									Fill_Block_Color(6,LIGHTBLUE);\n									LCD_DisGB2312String16x16(10+57+57,10,\"温度\",WHITE,LIGHTBLUE);\n									LCD_DisASCString(145,45,temperature,WHITE,2,KEEP_BG);\n								}\n								else//更新失败\n								{\n									LCD_DisARectangular(150,10,150+16,70,BLOCK_FRESH_COLOR);\n									LCD_DisGB2312String16x16(150,10,\"更新失败\",WHITE,BLOCK_FRESH_COLOR);\n									delay_ms(SHIFT_TIME);\n									Fill_Block_Color(6,LIGHTBLUE);\n									LCD_DisGB2312String16x16(10+57+57,10,\"温度\",WHITE,LIGHTBLUE);\n									LCD_DisASCString(145,45,temperature,WHITE,2,KEEP_BG);\n								}\n							}\n							else//连接失败\n							{\n								LCD_DisARectangular(150,10,150+16,70,BLOCK_FRESH_COLOR);\n								LCD_DisGB2312String16x16(150,10,\"连接失败\",WHITE,BLOCK_FRESH_COLOR);\n								delay_ms(SHIFT_TIME);\n								Fill_Block_Color(6,LIGHTBLUE);\n								LCD_DisGB2312String16x16(10+57+57,10,\"温度\",WHITE,LIGHTBLUE);\n								LCD_DisASCString(145,45,temperature,WHITE,2,KEEP_BG);\n							}\n						}\n						else//发送失败\n						{\n							LCD_DisARectangular(150,10,150+16,70,BLOCK_FRESH_COLOR);\n							LCD_DisGB2312String16x16(150,10,\"发送失败\",WHITE,BLOCK_FRESH_COLOR);\n							delay_ms(SHIFT_TIME);\n							Fill_Block_Color(6,LIGHTBLUE);\n							LCD_DisGB2312String16x16(10+57+57,10,\"温度\",WHITE,LIGHTBLUE);\n							LCD_DisASCString(145,45,temperature,WHITE,2,KEEP_BG);\n						}\n\n						 break;\n					case 7:\n						LCD_DisGB2312String16x16(10+57+57,10+71,\"湿度\",WHITE,BLOCK_FRESH_COLOR);\n						LCD_DisGB2312String16x16(150,14+10+71,\"更新中\",WHITE,BLOCK_FRESH_COLOR);\n						if(sim900a_get_data(RXdatabuf)==SUCCEED)\n						{\n							if(RXdatabuf[0]==SUCCEED)\n							{\n								if(RXdatabuf[6]!=2)\n								{\n									LCD_DisGB2312String16x16(150,10+71,\"更新成功\",WHITE,BLOCK_FRESH_COLOR);\n									delay_ms(SHIFT_TIME);\n									temp=(u16)RXdatabuf[9];\n									temp <<=8;\n									temp = (u16)(temp + RXdatabuf[10])/10;\n									sprintf(humidity,\"%02u\",temp);\n									Fill_Block_Color(7,LIGHTBLUE);\n									LCD_DisGB2312String16x16(10+57+57,10+71,\"湿度\",WHITE,LIGHTBLUE);\n									LCD_DisASCString(145,45+71,humidity,WHITE,2,KEEP_BG);\n								}\n								else//更新失败\n								{\n									LCD_DisARectangular(150,10+71,150+16,70+71,BLOCK_FRESH_COLOR);\n									LCD_DisGB2312String16x16(150,10+71,\"更新失败\",WHITE,BLOCK_FRESH_COLOR);\n									delay_ms(SHIFT_TIME);\n									Fill_Block_Color(7,LIGHTBLUE);\n									LCD_DisGB2312String16x16(10+57+57,10+71,\"湿度\",WHITE,LIGHTBLUE);\n									LCD_DisASCString(145,45+71,humidity,WHITE,2,KEEP_BG);\n								}\n							}\n							else//连接失败\n							{\n								LCD_DisARectangular(150,10+71,150+16,70+71,BLOCK_FRESH_COLOR);\n								LCD_DisGB2312String16x16(150,10+71,\"连接失败\",WHITE,BLOCK_FRESH_COLOR);\n								delay_ms(SHIFT_TIME);\n								Fill_Block_Color(7,LIGHTBLUE);\n								LCD_DisGB2312String16x16(10+57+57,10+71,\"湿度\",WHITE,LIGHTBLUE);\n								LCD_DisASCString(145,45+71,humidity,WHITE,2,KEEP_BG);\n							}\n						}\n						else//发送失败\n						{\n							LCD_DisARectangular(150,10+71,150+16,70+71,BLOCK_FRESH_COLOR);\n							LCD_DisGB2312String16x16(150,10+71,\"发送失败\",WHITE,BLOCK_FRESH_COLOR);\n							delay_ms(SHIFT_TIME);\n							Fill_Block_Color(7,LIGHTBLUE);\n							LCD_DisGB2312String16x16(10+57+57,10+71,\"湿度\",WHITE,LIGHTBLUE);\n							LCD_DisASCString(145,45+71,humidity,WHITE,2,KEEP_BG);\n						}\n						 break;	 \n					case 8:\n						Fill_Block_Color(8,BLOCK_FRESH_COLOR);\n						LCD_DisGB2312String16x16(22+57+57,24+142,\"返回\",WHITE,BLOCK_FRESH_COLOR);	\n						return;\n				/*		LCD_WriteReg(0X03);\n						#if (LCD_DIRECT == 1)	\n							LCD_WriteData(0X1030);		\n						#else\n							LCD_WriteData(0X1030);      //vertical\n						#endif\n						// LCD_ClrScr(LIGHTBLUE);\n						for(i=0;i<9;i++)\n						{\n							Fill_Block_Color(i,LIGHTBLUE);\n						}	\n						LCD_WriteReg(0X03);\n						#if (LCD_DIRECT == 1)	\n							LCD_WriteData(0X1038);		//horizontal\n						#else\n							LCD_WriteData(0X1030);      //vertical\n						#endif\n\n								TimeShowingFlag=RESET;\n								flagShowIcons=RESET;\n								DateShowingFlag=RESET;\n						\n\n								LCD_DisGB2312String16x16(22+57+57,24+142,\"返回\",WHITE,LIGHTBLUE);\n								while(1)\n								{\n									TouchValTemp=TOUCH_Scan(Touch_Ctrl_Pannel);//输出值为0－8或上相应的标志\n									if(TouchValTemp!=TOUCH_NULL)\n									{\n										if(TouchValTemp<9)\n										{\n											Ctrl_Pannel_Touch_FdBack(TouchValTemp,WHITE);\n										}\n										else\n										{\n											block = TouchValTemp & 0x0f;//block 取值为0~8\n											Ctrl_Pannel_Touch_Release_FdBack(block,LIGHTBLUE);\n											if(block==8)\n											{\n												break;\n											}\n										}\n									}\n								}\n								LCD_WriteReg(0X03);\n								#if (LCD_DIRECT == 1)	\n									LCD_WriteData(0X1008);		\n								#else\n									LCD_WriteData(0X1030);      //vertical\n								#endif\n								// LCD_ClrScr(LIGHTBLUE);\n								for(i=0;i<9;i++)\n								{\n									Fill_Block_Color(i,LIGHTBLUE);\n								}	\n								LCD_WriteReg(0X03);\n								#if (LCD_DIRECT == 1)	\n									LCD_WriteData(0X1038);		//horizontal\n								#else\n									LCD_WriteData(0X1030);      //vertical\n								#endif\n\n								TimeShowingFlag=RESET;\n								flagShowIcons=RESET;\n								DateShowingFlag=RESET;\n\n\n								//载入面板，各方块的状态维持最近一次更新的状态\n								if(block_state[AIR_CONDITIONER]==OFF)\n								{\n									LCD_DisGB2312String16x16(22,22,\"空调\",WHITE,LIGHTBLUE);\n								}\n								else\n								{\n									Fill_Block_Color(0,BLOCK_ON_COLOR);\n									LCD_DisGB2312String16x16(22,22,\"空调\",LIGHTBLUE,BLOCK_ON_COLOR);\n								}\n\n								if(block_state[LIVING_ROOM_LIGHT]==OFF)\n								{\n									LCD_DisGB2312String16x16(22,22+71-8,\"客厅灯\",WHITE,LIGHTBLUE);\n								}\n								else\n								{\n									Fill_Block_Color(1,BLOCK_ON_COLOR);\n									LCD_DisGB2312String16x16(22,22+71-8,\"客厅灯\",LIGHTBLUE,BLOCK_ON_COLOR);\n								}\n								\n								if(block_state[BEDROOM_LIGHT]==OFF)\n								{\n									LCD_DisGB2312String16x16(22,22+71-8+71,\"卧室灯\",WHITE,LIGHTBLUE);\n								}\n								else\n								{\n									Fill_Block_Color(2,BLOCK_ON_COLOR);\n									LCD_DisGB2312String16x16(22,22+71-8+71,\"卧室灯\",LIGHTBLUE,BLOCK_ON_COLOR);\n								}\n								\n								if(block_state[DOOR]==OFF)\n								{\n									LCD_DisGB2312String16x16(22+57,30,\"门\",WHITE,LIGHTBLUE);\n								}\n								else\n								{\n									Fill_Block_Color(3,BLOCK_ON_COLOR);\n									LCD_DisGB2312String16x16(22+57,30,\"门\",LIGHTBLUE,BLOCK_ON_COLOR);\n								}\n								if(block_state[WINDOW]==OFF)\n								{\n									LCD_DisGB2312String16x16(22+57,30+142,\"窗\",WHITE,LIGHTBLUE);\n								}\n								else\n								{\n									Fill_Block_Color(5,BLOCK_ON_COLOR);\n									LCD_DisGB2312String16x16(22+57,30+142,\"窗\",LIGHTBLUE,BLOCK_ON_COLOR);\n								}\n								LCD_DisGB2312String16x16(22+57,22+71,\"更新\",WHITE,LIGHTBLUE);\n\n								LCD_DisGB2312String16x16(10+57+57,10,\"温度\",WHITE,LIGHTBLUE);\n								\n								LCD_DisASCString(145,45,temperature,WHITE,2,KEEP_BG);\n								\n								LCD_DisGB2312String16x16(10+57+57,10+71,\"湿度\",WHITE,LIGHTBLUE);\n								\n								LCD_DisASCString(145,45+71,humidity,WHITE,2,KEEP_BG);\n\n								LCD_DisGB2312String16x16(22+57+57,24+142,\"返回\",WHITE,LIGHTBLUE);\n								break;*/		\n					default:break;\n				}\n			}\n		}\n	}\n}\n\n\n\n\n\n",
			"file": "USER/remote.c",
			"file_size": 28846,
			"file_write_time": 130547501700537655,
			"settings":
			{
				"buffer_size": 27200,
				"line_ending": "Windows",
				"scratch": true
			}
		},
		{
			"contents": "#ifndef __SIM900A_H__\n#define __SIM900A_H__	 \n#include \"sys.h\"\n\n#define ETHERNET 0\n#define	GPRS 1\n//////////////////////////////////////////////////////////////////////////////////	 \n//本程序只供学习使用，未经作者许可，不得用于其它任何用途\n//ALIENTEK STM32开发板\n//ATK-SIM900A GSM/GPRS模块驱动	  \n//正点原子@ALIENTEK\n//技术论坛:www.openedv.com\n//修改日期:2013/5/3\n//版本：V1.0\n//版权所有，盗版必究。\n//Copyright(C) 广州市星翼电子科技有限公司 2009-2019\n//All rights reserved	\n//********************************************************************************\n//无\n//////////////////////////////////////////////////////////////////////////////////	\n\n#define swap16(x) (x&0XFF)<<8|(x&0XFF00)>>8		//高低字节交换宏定义\n\n\nvoid xToChar1(uint8_t *data,char *s);\nu8 sim900a_tcpudp_test(u8* ipdata,char *p);\n//u8 sim_at_response(u8 mode);\nu8 sim_at_response(u8 mode,u8 *rx_buf);\nu8* sim900a_check_cmd(u8 *str);\nu8 sim900a_send_cmd(u8 *cmd,u8 *ack,u16 waittime);\nu8 sim900a_chr2hex(u8 chr);\nu8 sim900a_hex2chr(u8 hex);\nu8 sim900a_gprs_init(void);\nvoid xToChar(uint8_t *data,char *s);\nu8 sim900a_get_data(u8 *data);\nu8 sim900a_send_data(u8 *data);\nu8 sim900a_send_ctrl(u8 *data,u8 *data1);\nvoid SetNull(char *s);\nu8 sim900a_set_time(void);\nvoid sim900a_test(void);\nextern u8 TXdatabuf[32];\nextern u8 RXdatabuf[32];\nextern u8 networkOption;\n#endif\n\n\n\n\n\n",
			"file": "HARDWARE/SIM900A/sim900a.h",
			"file_size": 1389,
			"file_write_time": 130541878874325578,
			"settings":
			{
				"buffer_size": 1258,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "/*--------------------------------------------------------------------------\n// 文件名：LcdLib.c\n// 描述：  LCD库函数\n// 设计者：EU电子 \n// 深圳移优科技出品-版权所有-翻版必究\n// EU-热爱嵌入式开发\n// http://euse.taobao.com\n//-------------------------------------------------------------------------*/\n/* 头文件包含 INCLUDES */\n#include \"prohead.h\"\n#include \"driver.h\"\n#include \"lcdlib.h\"\n#include \"ASC8x16.h\"\n#include \"ASC12x24.h\" \n#include \"ASC16x32.h\"\n#include \"ASC24x48_Part.h\" \n#include \"GB2312.h\" \n#include \"image.h\"\n/*-------------------------------------------------------------------------------------------------------\n*  内部声明								 \n-------------------------------------------------------------------------------------------------------*/\n//lcd drivers\n#define	 LCD_RESET_H  		Driver_LcdReset(1)\n#define	 LCD_RESET_L  		Driver_LcdReset(0)\n#define	 LCD_CS_H  				Driver_LcdCS(1)\n#define	 LCD_CS_L  				Driver_LcdCS(0)\n#define	 LCD_RS_H  				Driver_LcdRS(1)\n#define	 LCD_RS_L  				Driver_LcdRS(0)\n#define	 LCD_RD_H  				Driver_LcdRD(1)\n#define	 LCD_RD_L  				Driver_LcdRD(0)\n#define	 LCD_WR_H  				Driver_LcdWR(1)\n#define	 LCD_WR_L  				Driver_LcdWR(0)\n#define  LCD_SEND(x)    	Driver_LcdSendData((x))\n#define  WIDTH 176\n//lcd resolution \n#if LCD_DIRECT==1\n	#define  LCD_ROW_NUM    176                //行数\n	#define  LCD_COL_NUM    220                //列数\n#else\n	#define  LCD_ROW_NUM    220                //行数\n	#define  LCD_COL_NUM    176                //列数\n#endif\n\n/*-------------------------------------------------------------------------------------------------------\n*  资源定义											 \n-------------------------------------------------------------------------------------------------------*/\n\n\n/*-------------------------------------------------------------------------------------------------------\n*  函数声明												 \n-------------------------------------------------------------------------------------------------------*/\n//lcd bottom funtions\nvoid LCD_WriteReg(u16 Index);\nvoid LCD_WriteData(u16 Data);\nvoid LCD_Delayms(u8 Num);\nvoid LCD_TimerCountHandle(void);\nvoid LCD_PortInit(void);\nvoid LCD_Reset(void);\nvoid LCD_Init(void);\n//back light\n//...\n//lcd display\nvoid LCD_OpenWin(u16 x0, u16 y0, u16 x1, u16 y1);\nvoid LCD_ClrScr(u16 BackColor);\nvoid LCD_DisAPoint(u16 x0, u16 y0, u16 Color);\nvoid LCD_DisALine(u16 x0, u16 y0, u8 dir, u16 lenth, u16 color);\nvoid LCD_DisABorder(u16 x0, u16 y0, u16 x1, u16 y1, u16 Color);\nvoid LCD_DisALoop(u16 x0, u16 y0, u8 r, u16 Color);\nvoid LCD_DisASquare(u16 x0, u16 y0, u16 wide, u16 Color);   \nvoid LCD_DisARectangular(u16 x0, u16 y0, u16 x1, u16 y1, u16 Color);\n// void LCD_DisASCString16x8(u16 x0, u16 y0, char *s, u16 fColor, u16 bColor);\nvoid LCD_DisGB2312String16x16(u16 x0, u16 y0, u8 *s, u16 fColor, u16 bColor);\nvoid LCD_DisGB2312String32x32(u16 x0, u16 y0, u8 *s, u16 fColor, u16 bColor);\nvoid LCD_DisAPhoto(u16 x0, u16 y0, u16 high, u16 wide,const u8 *pData);\n\n\n/*-------------------------------------------------------------------------------------------------------\n*  执行代码													 \n-------------------------------------------------------------------------------------------------------*/\n/********************************************************************************************************\n*  Function: LCD_WriteReg				                                                           \n*  Object: lcd write reg\n*  Input: index\n*  Output: none                                  \n*  brief: none\n********************************************************************************************************/\nvoid LCD_WriteReg(u16 Index)\n{\n		LCD_CS_L;\n		LCD_RS_L;\n		#if (LCD_BUSTYPE == 1)	\n			//16位数据总线\n			LCD_SEND(Index);\n			LCD_WR_L;\n			LCD_WR_H;\n		#else \n			//8位数据总线\n			LCD_SEND(Index/0x100);\n			LCD_WR_L;\n			LCD_WR_H;\n			LCD_SEND(Index%0x100);\n			LCD_WR_L;\n			LCD_WR_H;\n		#endif\n		LCD_CS_H;\n}\n\n/********************************************************************************************************\n*  Function: LCD_WR_DATA				                                                           \n*  Object: lcd write data\n*  Input: index and data\n*  Output: none                                  \n*  brief: none\n********************************************************************************************************/\nvoid LCD_WriteData(u16 Data)\n{\n		LCD_CS_L;\n		LCD_RS_H;\n		#if (LCD_BUSTYPE == 1)\n			//16位数据总线\n			LCD_SEND(Data);\n			LCD_WR_L;\n			LCD_WR_H;\n		#else \n			//8位数据总线\n			LCD_SEND(Data/0x100);\n			LCD_WR_L;\n			LCD_WR_H;\n			LCD_SEND(Data%0x100);\n			LCD_WR_L;\n			LCD_WR_H;\n		#endif\n		LCD_CS_H;\n}\n\n/********************************************************************************************************\n*  Function: LCD_Delayms				                                                           \n*  Object: lcd init wait..\n*  Input: Num\n*  Output: none                                  \n*  brief: time = Num * 1ms\n********************************************************************************************************/\nvoid LCD_Delayms(u8 Num)\n{\n		u16 Timer;\n		while(Num--)\n		{\n		 	Timer = 10;\n			while(Timer--); \n		}\n}\n\n/********************************************************************************************************\n*  Function: LCD_PortInit				                                                           \n*  Object: lcd port init\n*  Input: none\n*  Output: none                                  \n*  brief: none\n********************************************************************************************************/\nvoid LCD_PortInit(void)\n{\n		LCD_CS_H;\n		LCD_RS_H;\n		LCD_WR_H;\n		LCD_RD_H;\n}\n\n/********************************************************************************************************\n*  Function: LCD_Reset				                                                           \n*  Object: lcd reset control\n*  Input: none\n*  Output: none                                  \n*  brief: none\n********************************************************************************************************/\nvoid LCD_Reset(void)\n{\n		LCD_RESET_L;\n		LCD_Delayms(15);\n		LCD_RESET_H;\n		LCD_Delayms(5);\n}\n\n/********************************************************************************************************\n*  Function: Driver_LcdReset				                                                           \n*  Object: lcd reset control\n*  Input: sta\n*  Output: none                                  \n*  brief: none\n********************************************************************************************************/\nvoid LCD_Init(void)\n{ \n		//-- LCD PORT INIT --\n		LCD_PortInit();\n		//-- LCD RESET--\n		LCD_Reset();\n		//-------------- LGDP4522B Initial Sequence ---------------\n		//220*176\n		//power on..\n		LCD_WriteReg(0X14);\n		LCD_WriteData(0X0030);\n		LCD_WriteReg(0X0F);\n		LCD_WriteData(0X0008);\n		LCD_WriteReg(0X11);\n		LCD_WriteData(0X0231);\n		LCD_WriteReg(0X12);\n		LCD_WriteData(0X0009);\n		LCD_WriteReg(0X13);\n		LCD_WriteData(0X2958);\n		LCD_WriteReg(0X10);\n		LCD_WriteData(0X5268);\n		LCD_Delayms(40);\n		LCD_WriteReg(0X12);\n		LCD_WriteData(0X0019);\n		LCD_Delayms(40);\n		LCD_WriteReg(0X10);\n		LCD_WriteData(0X3260);\n		LCD_WriteReg(0X13);\n		LCD_WriteData(0X1958); \n		LCD_Delayms(40);\n		//gamma setting..\n		LCD_WriteReg(0X30);\n		LCD_WriteData(0X0000);\n		LCD_WriteReg(0X31);\n		LCD_WriteData(0X0501);\n		LCD_WriteReg(0X32);\n		LCD_WriteData(0X0207);\n		LCD_WriteReg(0X33);\n		LCD_WriteData(0X0502);\n		LCD_WriteReg(0X34);\n		LCD_WriteData(0X0007);\n		LCD_WriteReg(0X35);\n		LCD_WriteData(0X0601);\n		LCD_WriteReg(0X36);\n		LCD_WriteData(0X0707);\n		LCD_WriteReg(0X37);\n		LCD_WriteData(0X0305);\n		LCD_WriteReg(0X38);\n		LCD_WriteData(0X040e);\n		LCD_WriteReg(0X39);\n		LCD_WriteData(0X040e);\n		LCD_WriteReg(0X3a);\n		LCD_WriteData(0X0101);\n		LCD_WriteReg(0X3b);\n		LCD_WriteData(0X0101);\n		LCD_WriteReg(0X3c);\n		LCD_WriteData(0X0101);\n		LCD_WriteReg(0X3d);\n		LCD_WriteData(0X0101);\n		LCD_WriteReg(0X3e);\n		LCD_WriteData(0X0001);\n		LCD_WriteReg(0X3f);\n		LCD_WriteData(0X0001);\n		LCD_WriteReg(0X21);\n		LCD_WriteData(0x0000);\n		//display mode..			\n		LCD_WriteReg(0X01);  \n		#if (LCD_DIRECT == 1)		\n			LCD_WriteData(0X031B);        \n		#else\n			LCD_WriteData(0X011B);			\n		#endif\n		LCD_WriteReg(0X02);\n		LCD_WriteData(0X0700);\n\n		LCD_WriteReg(0X03);\n		#if (LCD_DIRECT == 1)	\n			LCD_WriteData(0X1038);		//horizontal\n		#else\n			LCD_WriteData(0X1030);      //vertical\n		#endif\n		LCD_WriteReg(0X08);\n		LCD_WriteData(0X1010);\n		LCD_WriteReg(0X0A);\n		LCD_WriteData(0X4420);\n		LCD_WriteReg(0X0B);\n		LCD_WriteData(0X5030);\n		LCD_WriteReg(0X0F);\n		LCD_WriteData(0X000D);\n		LCD_Delayms(10);\n		//display on..\n		LCD_WriteReg(0X07);\n		LCD_WriteData(0X0005);\n		LCD_WriteReg(0X07);\n		LCD_WriteData(0X0025);\n		LCD_WriteReg(0X07);\n		LCD_WriteData(0X0027);\n		LCD_WriteReg(0X07);\n		LCD_WriteData(0X0037);	\n}\n\n/********************************************************************************************************\n*  Function: LCD_OpenWin				                                                           \n*  Object: lcd open window for display\n*  Input: x0,y0, x1, y1\n*  Output: none                                  \n*  brief: none\n********************************************************************************************************/\nvoid LCD_OpenWin(u16 x0, u16 y0, u16 x1, u16 y1)\n{\n		#if (LCD_DIRECT == 1)\n			LCD_WriteReg(0x0044);\n			LCD_WriteData((x1<<8)+x0);\n			LCD_WriteReg(0x0045);\n			LCD_WriteData((y1<<8)+y0);	\n			LCD_WriteReg(0x0021);\n			LCD_WriteData((y0<<8)+x0); \n		#else\n			LCD_WriteReg(0x0045);\n			LCD_WriteData((x1<<8)+x0);\n			LCD_WriteReg(0x0044);\n			LCD_WriteData((y1<<8)+y0);\n			LCD_WriteReg(0x0021);\n			LCD_WriteData((x0<<8)+y0); \n		#endif\n			LCD_WriteReg(0x0022);\n		//S_DogFeed();\n}\n\n/********************************************************************************************************\n*  Function: LCD_ClrScr				                                                           \n*  Object: lcd clear screen\n*  Input: backcolor\n*  Output: none                                  \n*  brief: none\n********************************************************************************************************/\nvoid LCD_ClrScr(u16 BackColor)\n{\n		u16 i,j;\n		LCD_OpenWin(0, 0, LCD_ROW_NUM-1, LCD_COL_NUM-1);\n		for(i = 0; i < LCD_ROW_NUM; i++)\n			 for(j =0; j < LCD_COL_NUM; j++)\n					 LCD_WriteData(BackColor);\n}\n\n/********************************************************************************************************\n*  Function: LCD_DisAPoint				                                                           \n*  Object: Display a point at screen\n*  Input: site and color\n*  Output: none                                  \n*  brief: none\n********************************************************************************************************/\nvoid LCD_DisAPoint(u16 x0, u16 y0, u16 Color)\n{\n		LCD_DisASquare(x0, y0, 1, Color);\n}\n\n/********************************************************************************************************\n*  Function: LCD_DisALine				                                                           \n*  Object: Display a line\n*  Input: site dir lenth wide color\n*  Output: none                                  \n*  brief: none\n********************************************************************************************************/\nvoid LCD_DisALine(u16 x0, u16 y0, u8 dir, u16 lenth, u16 color)\n{\n		u16 x1,y1;\n		x1 = x0;\n		y1 = y0;\n		if(dir == 1)\n			y1 = y1 + lenth;\n		else\n			x1 = x1 + lenth;\n		LCD_DisARectangular(x0, y0, x1, y1, color);\n}\n\n/********************************************************************************************************\n*  Function: LCD_DisABorder				                                                           \n*  Object: Display a border\n*  Input: x0, y0, x1, y1, color\n*  Output: none                                  \n*  brief: none\n********************************************************************************************************/\nvoid LCD_DisABorder(u16 x0, u16 y0, u16 x1, u16 y1, u16 Color)\n{\n		LCD_DisALine(x0, y0, 1, y1-y0, Color);\n		LCD_DisALine(x1, y0, 1, y1-y0, Color);\n		LCD_DisALine(x0, y0, 2, x1-x0, Color);\n		LCD_DisALine(x0, y1, 2, x1-x0, Color);\n}\n\n/********************************************************************************************************\n*  Function: LCD_DisALoop				                                                           \n*  Object: Display a loop\n*  Input: site,radius and color\n*  Output: none                                  \n*  brief: none\n********************************************************************************************************/\nvoid LCD_DisALoop(u16 x0, u16 y0, u8 r, u16 Color)\n{\n		s16 a,b,next;\n		a	=	0;\n		b = r;	  \n		next = 3 - (r<<1);            \n		while(a <= b)\n		{\n				LCD_DisAPoint(x0+a, y0-b, Color);             \n				LCD_DisAPoint(x0+b, y0-a, Color);                      \n				LCD_DisAPoint(x0+b, y0+a, Color);                          \n				LCD_DisAPoint(x0+a, y0+b, Color);             \n				LCD_DisAPoint(x0-a, y0+b, Color);                  \n				LCD_DisAPoint(x0-b, y0+a, Color);             \n				LCD_DisAPoint(x0-a, y0-b, Color);                          \n				LCD_DisAPoint(x0-b, y0-a, Color);              	         \n				a++;\n				//use the bresenham    \n				if(next<0)\n					next += 4*a+6;	  \n				else\n				{\n						next += 10+4*(a-b);   \n						b--;\n				} 						    \n		}\n} \n\n/********************************************************************************************************\n*  Function: LCD_DisASquare				                                                           \n*  Object: Display a square\n*  Input: start point, wide, color\n*  Output: none                                  \n*  brief: none\n********************************************************************************************************/\nvoid LCD_DisASquare(u16 x0, u16 y0, u16 wide, u16 Color)\n{\n		u16 i,j;\n		LCD_OpenWin(x0, y0, x0+wide-1, y0+wide-1);\n		for(i = 0; i < wide; i++)\n			for(j = 0; j < wide; j++)\n					 LCD_WriteData(Color);\n}\n\n/********************************************************************************************************\n*  Function: LCD_DisARectangular				                                                           \n*  Object: Display a rectangular\n*  Input: start point, end point, color\n*  Output: none                                  \n*  brief: none\n********************************************************************************************************/\nvoid LCD_DisARectangular(u16 x0, u16 y0, u16 x1, u16 y1, u16 Color)\n{\n		u16 i,j;\n		LCD_OpenWin(x0, y0, x1, y1);\n		for(i = 0; i <= x1-x0; i++)\n			 for(j = 0; j <= y1-y0; j++)\n					 LCD_WriteData(Color);\n}\n\n/********************************************************************************************************\n*  Function: LCD_DisGB2312String16x16				                                                           \n*  Object: display a chinese string\n*  Input: site, char, fColor, bColor\n*  Output: none                                  \n*  brief: none\n********************************************************************************************************/\nvoid LCD_DisGB2312String16x16(u16 x0, u16 y0, u8 *s, u16 fColor, u16 bColor)\n{\n		u16 Num;\n		u8 i,j,m,l = 1;\n		while(*s)\n		{\n				LCD_OpenWin(x0, y0+(16-1)*(l-1), x0+16-1, y0+(16-1)*l);\n				for(Num = 0; Num < sizeof(GB2312Code16x16)/35; Num++)\n				{\n						if((GB2312Code16x16[Num].Head[0] == *s) && (GB2312Code16x16[Num].Head[1] == *(s+1)))\n						{ \n								for(i = 0; i < 32; i++) \n								{\n										m = GB2312Code16x16[Num].Infor[i];\n										for(j = 0; j<8; j++) \n										{\n												if(m&CHSBIT7)\n													LCD_WriteData(fColor);\n												else \n													LCD_WriteData(bColor);\n												m<<=1;\n										} \n								}\n						}  \n				}\n				s+=2;\n				l++;\n		}\n}\n\n/********************************************************************************************************\n*  Function: LCD_DisGB2312String32x32				                                                           \n*  Object: display a chinese string\n*  Input: site, char, fColor, bColor\n*  Output: none                                  \n*  brief: none\n********************************************************************************************************/\n\nvoid LCD_DisGB2312String32x32(u16 x0, u16 y0, u8 *s, u16 fColor, u16 bColor)\n{\n		u16 Num;\n		u8 i,j,m,l = 1;\n		while(*s)\n		{\n				LCD_OpenWin(x0, y0+(32-1)*(l-1), x0+32-1, y0+(32-1)*l);\n				for(Num = 0; Num < sizeof(GB2312Code32x32)/131; Num++)\n				{\n						if((GB2312Code32x32[Num].Head[0] == *s) && (GB2312Code32x32[Num].Head[1] == *(s+1)))\n						{ \n								for(i = 0; i < 128; i++) \n								{\n										m = GB2312Code32x32[Num].Infor[i];\n										for(j = 0; j<8; j++) \n										{\n												if(m&CHSBIT7)\n													LCD_WriteData(fColor);\n												else \n													LCD_WriteData(bColor);\n												m<<=1;\n										} \n								}\n						}  \n				}\n				s+=2;\n				l++;\n		}\n}\n\n\n/********************************************************************************************************\n*  Function: LCD_DisAPhoto				                                                           \n*  Object: display a photo\n*  Input: Site(x0,y0), high and wide, pData\n*  Output: none                                  \n*  brief: none\n********************************************************************************************************/\nvoid LCD_DisAPhoto(u16 x0, u16 y0, u16 high, u16 wide,const u8 *pData)\n{\n		unsigned int i,lenth;\n		lenth = high * wide * 2;  		//RGB565 每一像素点占用两个字节\n		LCD_OpenWin(x0, y0, x0+high-1, y0+wide-1);\n		for(i = 0; i < lenth; i+=2)\n			LCD_WriteData((*(pData+i))*0x100 + (*(pData+i+1)));\n}\n\n/***************************************自编函数分割线**************************************************/\n\n/********************************************************************************************************\n*  Function: bgColor				                                                           \n*  Object: get the certain point's background colour \n*  Input: start point x(0~219) ,y(0~175),the pointer\n*  Output: colour's value                                 \n*  brief: none\n********************************************************************************************************/\nu16 bgColor(u16 x,u16 y,const u8 *pData)\n{	\n	unsigned int i;\n	#if(LCD_DIRECT == 1)\n		i = (x*220 + y)*2;\n	#else \n		i = (x*176 + y)*2;\n	#endif\n	return (*(pData+i))*0x100 + (*(pData+i+1));\n}\n/********************************************************************************************************\n*  Function: LCD_DisASC1				                                                           \n*  Object: Display a ASC\n*  Input: site, char, fColor, bColor,size,\n		  method(1:re-draw the whole rectangular area of the string ,0:only draw the dots of the string)\n*  Output: none                                  \n*  brief: none\n********************************************************************************************************/\nvoid LCD_DisASCString(u16 x0, u16 y0, char *s, u16 fColor,u8 size,bool method)\n{\n		u16 i=0,j=0,l=1;\n		u8 adjust=0;\n		u8 char_width;\n		u8 char_height;		 \n		const u8 * char_set;\n		u16 char_byte;\n		switch(size)\n		{\n			case 1:\n				char_width=8;\n				char_height=16;\n				char_set=InforCode_Font8x16;\n				break;\n			/*case 2:\n				char_width=16;\n				char_height=32;\n				char_set=InforCode_Font16x32;\n				break;*/\n			case 2:\n				char_width=12;\n				char_height=24;\n				char_set=InforCode_Font12x24;\n				break;\n			case 3:\n				char_width=24;\n				char_height=48;\n				char_set=InforCode_Font24x48;\n				adjust=48;//24X48的字库只有0~9和：，由字符“0”~\":\" -48可得到在该字符在字库的对应的位置\n				break;	\n			case 4:\n				char_width=16;\n				char_height=32;\n				char_set=InforCode_Font16x32;\n				adjust=45;//24X48的字库只有- . / 0~9和：，由字符“0”~\":\" -48可得到在该字符在字库的对应的位置\n				break;		\n		}\n		char_byte = char_width * char_height/8;\n\n		if(size==2)//尺寸（长，宽）不为8的倍数的字符需要特别处理，以下为12x24的字符显示程序，还不能适配其他非8倍尺寸的字符，若有需要须再修改\n		{\n			char_byte = 16 * char_height/8;\n			switch(method)\n			{\n				case RE_WRITE_BG:\n					while(*s)\n					{\n							LCD_OpenWin(x0, y0+char_width*(l-1), x0+char_height-1, y0+char_width*l-1);\n							for(i=0; i<char_byte; i++) \n							{\n									u8 m =*( char_set+(*s-adjust)*char_byte+i);\n									for(j=0; j<8; j++) \n									{\n											if(m&CHSBIT7)\n												LCD_WriteData(fColor);\n											else   \n												LCD_WriteData(bgColor(x0+i*8/char_width,y0+char_width*(l-1)+i*8%char_width+j, gImage_bg));\n											m <<= 1;\n									}\n									i++;\n									m =*( char_set+(*s-adjust)*char_byte+i);\n									for(j=0; j<4; j++) \n									{\n											if(m&CHSBIT7)\n												LCD_WriteData(fColor);\n											else   \n												LCD_WriteData(bgColor(x0+i*8/char_width,y0+char_width*(l-1)+i*8%char_width+j, gImage_bg));\n											m <<= 1;\n									}\n\n							}\n							s++;\n							l++;\n					}\n					break;\n				case KEEP_BG:\n					l=0;\n					while(*s)\n					{\n						u8 k;\n						u16 x,y;\n						for(i=0;i<char_height;i++)\n						{\n							for(j=0;j<16/8;j++)\n							{\n								u8 m =*( char_set+(*s-adjust)*char_byte+i*16/8+j);\n								for(k=0; k<8; k++) \n								{\n										if(m&CHSBIT7)\n										{	\n											x=x0+i;\n											y=y0+j*8+l*char_width+k;\n											LCD_OpenWin(x,y,x,y);\n											LCD_WriteData(fColor);\n										}\n										m <<= 1;\n								}\n								j++;\n								m =*( char_set+(*s-adjust)*char_byte+i*16/8+j);\n								for(k=0; k<4; k++) \n								{\n										if(m&CHSBIT7)\n										{	\n											x=x0+i;\n											y=y0+j*8+l*char_width+k;\n											LCD_OpenWin(x,y,x,y);\n											LCD_WriteData(fColor);\n										}\n										m <<= 1;\n								}\n							}\n						}\n						s++;\n						l++;  \n					}\n					break;\n			}\n		}\n		else\n		{\n			switch(method)\n			{\n				case RE_WRITE_BG:\n					while(*s)\n					{\n							LCD_OpenWin(x0, y0+char_width*(l-1), x0+char_height-1, y0+char_width*l-1);\n							for(i=0; i<char_byte; i++) \n							{\n									u8 m =*( char_set+(*s-adjust)*char_byte+i);\n									for(j=0; j<8; j++) \n									{\n											if(m&CHSBIT7)\n												LCD_WriteData(fColor);\n											else   \n												LCD_WriteData(bgColor(x0+i*8/char_width,y0+char_width*(l-1)+i*8%char_width+j, gImage_bg));\n											m <<= 1;\n									}\n							}\n							s++;\n							l++;\n					}\n					break;\n				case KEEP_BG:\n					l=0;\n					while(*s)\n					{\n						u8 k;\n						u16 x,y;\n						for(i=0;i<char_height;i++)\n						{\n							for(j=0;j<char_width/8;j++)\n							{\n								u8 m =*( char_set+(*s-adjust)*char_byte+i*char_width/8+j);\n								for(k=0; k<8; k++) \n								{\n										if(m&CHSBIT7)\n										{	\n											x=x0+i;\n											y=y0+j*8+l*char_width+k;\n											LCD_OpenWin(x,y,x,y);\n											LCD_WriteData(fColor);\n										}\n										m <<= 1;\n								}\n							}\n						}\n						s++;\n						l++;  \n					}\n					break;\n			}\n		}\n}\n/********************************************************************************************************\n*  Function: LCD_DisGB2312String32x32				                                                           \n*  Object: display a chinese string\n*  Input: site, char, fColor, bColor\n*  Output: none                                  \n*  brief: none\n********************************************************************************************************/\nvoid LCD_DisGB2312String(u16 x0, u16 y0, u8 *s, u16 fColor,u8 size)\n{\n		u16 Num;\n		u8 i,j,m,l = 1;\n		u8 char_width;\n		u8 char_height;	\n		u16 char_byte;\n		switch (size)\n		{\n			case 1:\n				char_width=16;\n				char_height=16;\n				char_byte = char_width * char_height/8;\n				while(*s)\n				{\n						LCD_OpenWin(x0, y0+char_width*(l-1), x0+char_height-1, y0+char_width*l-1);\n						for(Num = 0; Num < sizeof(GB2312Code16x16)/35; Num++)\n						{\n								if((GB2312Code16x16[Num].Head[0] == *s) && (GB2312Code16x16[Num].Head[1] == *(s+1)))\n								{ \n										for(i = 0; i < char_byte; i++) \n										{\n												m = GB2312Code16x16[Num].Infor[i];\n												for(j = 0; j<8; j++) \n												{\n														if(m&CHSBIT7)\n															LCD_WriteData(fColor);\n														else \n															LCD_WriteData(bgColor(x0+i*8/char_width,y0+char_width*(l-1)+i*8%char_width+j, gImage_bg));\n														m<<=1;\n												} \n										}\n								}  \n						}\n						s+=2;\n						l++;\n				}\n				break;\n			case 2:\n				char_width=32;\n				char_height=32;\n				char_byte = char_width * char_height/8;\n				while(*s)\n				{\n						LCD_OpenWin(x0, y0+char_width*(l-1), x0+char_height-1, y0+char_width*l-1);\n						for(Num = 0; Num < sizeof(GB2312Code32x32)/131; Num++)\n						{\n								if((GB2312Code32x32[Num].Head[0] == *s) && (GB2312Code32x32[Num].Head[1] == *(s+1)))\n								{ \n										for(i = 0; i < char_byte; i++) \n										{\n												m = GB2312Code32x32[Num].Infor[i];\n												for(j = 0; j<8; j++) \n												{\n														if(m&CHSBIT7)\n															LCD_WriteData(fColor);\n														else \n															LCD_WriteData(bgColor(x0+i*8/char_width,y0+char_width*(l-1)+i*8%char_width+j, gImage_bg));\n														m<<=1;\n												} \n										}\n								}  \n						}\n						s+=2;\n						l++;\n				}\n				break;\n		}\n\n}\n/********************************************************************************************************\n*  Function: LCD_ClrARectangular				                                                           \n*  Object: Re\n*  Input: start point, end point, \n*  Output: none                                  \n*  brief: none\n********************************************************************************************************/\nvoid LCD_ClrARectangular(u16 x0, u16 y0, u16 x1, u16 y1)\n{\n		u16 i,j;\n		LCD_OpenWin(x0, y0, x1, y1);\n		for(i = 0; i <= x1-x0; i++)\n			 for(j = 0; j <= y1-y0; j++)\n			 {	\n		 		LCD_WriteData(bgColor(x0+i,y0+j,gImage_bg));\n			 }	\n					 \n}\n/********************************************************************************************************\n*  Function: LCD_DisACircle				                                                           \n*  Object: Display a loop\n*  Input: site,radius and color\n*  Output: none                                  \n*  brief: none\n********************************************************************************************************/\nvoid LCD_DisACircle(u16 x0, u16 y0, u8 r, u16 Color)\n{\n	char i;\n	for(i=r;i>0;i--)\n	{\n		LCD_DisALoop(x0,y0,i,Color);\n	}\n} \n\n/********************************************************************************************************\n*  Function: LCD_DisAIcon				                                                           \n*  Object: display a Icon\n*  Input: Site(x0,y0), high and wide, pData\n*  Output: none                                  \n*  brief: none\n********************************************************************************************************/\nvoid LCD_DisAIcon(u16 x0, u16 y0, u16 height, u16 width,const u8 *pData,u16 removeColor)\n{\n		u16 temp;\n		unsigned int i,lenth;\n		lenth = height * width * 2;  		//RGB565 每一像素点占用两个字节\n		LCD_OpenWin(x0, y0, x0+height-1, y0+width-1);\n		for(i = 0; i < lenth; i+=2)\n		{\n			temp=(*(pData+i))*0x100 + (*(pData+i+1));\n			if(temp!=removeColor)\n			{\n				LCD_WriteData(temp);\n			}\n			else\n			{\n				LCD_WriteData(bgColor(x0+i/2/width,y0+i/2%width,gImage_bg));\n			}\n		}\n	\n}\n/********************************************************************************************************\n*  Function: LCD_DisLines				                                                           \n*  Object: Display  lines\n*  Input: site dir lenth wide color\n*  Output: none                                  \n*  brief: none\n********************************************************************************************************/\nvoid LCD_DisLines(u16 x0, u16 y0, u8 dir, u16 lenth,u16 width, u16 color)\n{\n		u16 x1,y1;\n		x1 = x0;\n		y1 = y0;\n		if(dir == 1)\n		{\n			x1 = x1 + width;\n			y1 = y1 + lenth;\n		}\n		else\n		{\n			x1 = x1 + lenth;\n			y1 = y1 + width;\n		}\n		LCD_DisARectangular(x0, y0, x1, y1, color);\n}\n/********************************************************************************************************\n*  Function: LCD_DisAWideBorder				                                                           \n*  Object: Display a border\n*  Input: x0, y0, x1, y1, color\n*  Output: none            `                      \n*  brief: none\n********************************************************************************************************/\nvoid LCD_DisAWideBorder(u16 x0, u16 y0, u16 x1, u16 y1,u16 width, u16 Color)\n{\n		u16 i ;\n		for(i=0;i<width;i++)\n		{\n			LCD_DisABorder(x0+i,y0+i,x1-i,y1-i,Color);\n		}\n}\n/********************************************************************************************************\n*  Function: LCD_DisAIconWithBGC				                                                           \n*  Object: display a Icon\n*  Input: Site(x0,y0), high and wide, pData\n*  Output: none                                  \n*  brief: none\n********************************************************************************************************/\nvoid LCD_DisAIconWithBGC(u16 x0, u16 y0, u16 height, u16 width,const u8 *pData,u16 removeColor,u16 fColor,u16 bColor)\n{\n		u16 temp;\n		unsigned int i,lenth;\n		lenth = height * width * 2;  		\n		LCD_OpenWin(x0, y0, x0+height-1, y0+width-1);\n		for(i = 0; i < lenth; i+=2)\n		{\n			temp=(*(pData+i))*0x100 + (*(pData+i+1));\n			if(temp!=removeColor)\n			{\n				LCD_WriteData(fColor);\n			}\n			else\n			{\n				LCD_WriteData(bColor);\n			}\n		}\n}\n/********************************************************************************************************\n*  Function: LCD_DisAIconWithoutBGC				                                                           \n*  Object: display a Icon\n*  Input: Site(x0,y0), high and wide, pData\n*  Output: none                                  \n*  brief: none\n********************************************************************************************************/\nvoid LCD_DisAIconWithoutBGC(u16 x0, u16 y0, u16 height, u16 width,const u8 *pData,u16 chosenColor)\n{\n		u16 temp;\n		unsigned int i,lenth;\n		lenth = height * width * 2;  		//RGB565 每一像素点占用两个字节\n		LCD_OpenWin(x0, y0, x0+height-1, y0+width-1);\n		for(i = 0; i < lenth; i+=2)\n		{\n			temp=(*(pData+i))*0x100 + (*(pData+i+1));\n			if(temp==chosenColor)\n			{\n				LCD_WriteData(temp);\n			}\n			else\n			{\n				LCD_WriteData(bgColor(x0+i/2/width,y0+i/2%width,gImage_bg));\n			}\n		}\n	\n}\n\n\nvoid Show_Ch_Message_Centre(u8 *message)\n{\n	LCD_ClrARectangular(80,50,96,200);\n	LCD_DisGB2312String(80,110-16*strlen((const char*)message)/4,message,WHITE,1);\n}\nvoid ShowEn_Message_Centre(char *message)\n{ \n	LCD_ClrARectangular(80,50,96,200);\n	LCD_DisASCString(80,110-12*strlen((const char*)message)/2,message,WHITE,2,RE_WRITE_BG);\n}\n\n",
			"file": "HARDWARE/TFT/LcdLib.c",
			"file_size": 31566,
			"file_write_time": 130541233902292853,
			"settings":
			{
				"buffer_size": 30341,
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "",
	"command_palette":
	{
		"height": 58.0,
		"selected_items":
		[
			[
				"remove p",
				"Package Control: Remove Package→删除程序包"
			],
			[
				"packgae",
				"Package Control: Add Channel→添加资源库链接"
			],
			[
				"install",
				"Package Control: Install Package→安装程序包"
			],
			[
				"inst",
				"Package Control: Install Package→安装程序包"
			],
			[
				"insta",
				"Package Control: Install Package→安装程序包"
			]
		],
		"width": 632.0
	},
	"console":
	{
		"height": 146.0,
		"history":
		[
			"import urllib2,os; pf='Package Control.sublime-package'; ipp=sublime.installed_packages_path(); os.makedirs(ipp) if not os.path.exists(ipp) else None; urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler())); open(os.path.join(ipp,pf),'wb').write(urllib2.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read()); print('Please restart Sublime Text to finish installation')"
		]
	},
	"distraction_free":
	{
		"menu_visible": false,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"file_history":
	[
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/USER/network.c",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/USER/network.h",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/HARDWARE/LD3320/LD3320.c",
		"/F/中转站/desktop-fake/sim900a.c",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/HARDWARE/TFT/GB2312.h",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/HARDWARE/TFT/Touch.c",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/USER/UI.c",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/HARDWARE/SIM900A/sim900a.h",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/HARDWARE/TFT/lcdlib.h",
		"/F/中转站/desktop-fake/setting.c",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/HARDWARE/KEY/key.h",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/HARDWARE/KEY/key.c",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/HARDWARE/USART2/usart2.c",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/HARDWARE/LD3320/LD3320_config.h",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/HARDWARE/TFT/ASC16x32.h",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/HARDWARE/TFT/ASC12x24.h",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/HARDWARE/RTC/rtc.h",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/HARDWARE/RTC/rtc.c",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/USER/setting.c",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/STM32F10x_FWLib/inc/stm32f10x_rtc.h",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/OBJ/RTC.htm",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/OBJ/RTC.hex",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/OBJ/rtc.crf",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/OBJ/rtc.d",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/OBJ/RTC.axf",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/USER/RTC_Target 1.dep",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/OBJ/usmart_config.crf",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/USER/RTC.map",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/USER/RTC.uvgui.zhx",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/USER/remote.h",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/USER/remote.c",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/OBJ/remote.d",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/OBJ/remote.crf",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/OBJ/setting.crf",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/OBJ/stm32f10x_exti.crf",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/CORE/core_cm3.c",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/CORE/startup_stm32f10x_md.s",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/OBJ/ui.crf",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/OBJ/lcdlib.d",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/OBJ/lcdlib.crf",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/OBJ/lcd.crf",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/USER/JLinkLog.txt",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/HARDWARE/USART2/usart2.h",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/HARDWARE/TFT/LcdLib.c",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/HARDWARE/LD3320/LD3320.h",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/OBJ/sim900a.d",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/OBJ/sim900a.crf",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/OBJ/stm32f10x_it.crf",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/OBJ/ExtDll.iex",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/keilkilll.bat",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/OBJ/key.crf",
		"/F/中转站/desktop-fake/省赛/moudle/LD3320 -Board/code/STM32/Open103Z/User/LD3320/LD3320.c",
		"/F/中转站/desktop-fake/省赛/program/example/库函数版本-（适合战舰STM32开发板）扩展实验5 ATK-SIM900A GSM模块测试实验/LD3320/LD3320.c",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/USER/stm32f10x.h",
		"/D/c-setup/sublime text/Sublime Text 3/Data/Packages/EncodingHelper/EncodingHelper.sublime-settings",
		"/D/c-setup/sublime text/Sublime Text 3/Data/Packages/User/ConvertToUTF8.sublime-settings",
		"/D/c-setup/sublime text/Sublime Text 3/Data/Packages/ConvertToUTF8/ConvertToUTF8.sublime-settings",
		"/C/Users/zhx/AppData/Local/Temp/Rar$DI00.755/LD3320.c",
		"/D/c-setup/sublime text/Sublime Text 3/Data/Packages/User/Default (Windows).sublime-keymap",
		"/D/c-setup/sublime text/Sublime Text 3/Data/Packages/CTags/Default.sublime-keymap",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/STM32F10x_FWLib/src/stm32f10x_rcc.c",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/HARDWARE/SIM900A/sim900a.c",
		"/D/c-setup/sublime text/Sublime Text 3/Data/Packages/User/Preferences.sublime-settings",
		"/D/c-setup/sublime text/Sublime Text 3/Data/Packages/User/CTags.sublime-settings",
		"/D/c-setup/sublime text/Sublime Text 3/Data/Packages/CTags/CTags.sublime-settings",
		"/D/c-setup/sublime text/Sublime Text 3/Data/Packages/CTags/Default.sublime-mousemap",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/HARDWARE/TIMER/timer.c",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/STM32F10x_FWLib/src/stm32f10x_spi.c",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/STM32F10x_FWLib/src/stm32f10x_gpio.c",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/OBJ/timer.crf",
		"/D/c-setup/sublime text/Sublime Text 3/Data/Packages/Default/Default (Windows).sublime-keymap",
		"/D/c-setup/sublime text/Sublime Text 3/Data/Packages/User/JSON.sublime-settings",
		"/C/Users/zhx/AppData/Local/Temp/Rar$DI01.652/LD3320.c",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/USER/UI.h",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/STM32F10x_FWLib/inc/stm32f10x_dac.h",
		"/C/Users/zhx/AppData/Local/Temp/Rar$DI00.965/LD3320.c",
		"/C/Users/zhx/AppData/Local/Temp/Rar$DI01.607/LD3320.c",
		"/C/Users/zhx/AppData/Local/Temp/Rar$DI00.881/LD3320.c",
		"/F/中转站/desktop-fake/LD3320.c",
		"/F/中转站/desktop-fake/remote.c",
		"/F/中转站/desktop-fake/main.c",
		"/F/中转站/desktop-fake/省赛/program/code/ld3320.c",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/HARDWARE/TFT/Touch.h",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/HARDWARE/TFT/image.c",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/HARDWARE/TFT/image.h",
		"/F/中转站/desktop-fake/RTC/HARDWARE/LD3320/LD3320.c",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/HARDWARE/TFT/ASC8x16.h",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/HARDWARE/TFT/ASC24x48_Part.h",
		"/F/中转站/desktop-fake/RTC/HARDWARE/TFT/Touch.c",
		"/F/中转站/desktop-fake/RTC/HARDWARE/TFT/Driver.c",
		"/F/中转站/desktop-fake/RTC/HARDWARE/KEY/key.c",
		"/F/中转站/desktop-fake/UI.c",
		"/C/Users/zhx/AppData/Local/Temp/Rar$DI12.173/main.c",
		"/C/Users/zhx/AppData/Local/Temp/Rar$DI01.168/UI.c",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/HARDWARE/TFT/Driver.c",
		"/F/中转站/desktop-fake/省赛/program/code/test_code.c",
		"/C/Users/zhx/AppData/Local/Temp/Rar$DI16.593/remote.c",
		"/C/Users/zhx/AppData/Local/Temp/Rar$DI01.753/remote.c",
		"/F/中转站/desktop-fake/sim900a.h",
		"/C/Users/zhx/AppData/Local/Temp/Rar$DI01.284/UI.c",
		"/C/Users/zhx/AppData/Local/Temp/Rar$DI08.471/UI.c",
		"/C/Users/zhx/AppData/Local/Temp/Rar$DI05.026/Touch.c",
		"/C/Users/zhx/AppData/Local/Temp/Rar$DI01.018/UI.c",
		"/F/中转站/desktop-fake/SmartWatch8.8/HARDWARE/KEY/key.h",
		"/F/中转站/desktop-fake/SmartWatch8.8/HARDWARE/LD3320/LD3320_config.h",
		"/F/中转站/desktop-fake/SmartWatch8.8/HARDWARE/LD3320/LD3320.c",
		"/F/中转站/desktop-fake/SmartWatch8.8/HARDWARE/LD3320/LD3320.h",
		"/F/中转站/desktop-fake/SmartWatch8.8/HARDWARE/USART2/usart2.h",
		"/F/中转站/desktop-fake/SmartWatch8.8/USER/main.c",
		"/F/中转站/desktop-fake/SmartWatch8.8/HARDWARE/TFT/image.c",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/USER/main.c",
		"/F/中转站/desktop-fake/省赛/program/example/库函数版本-（适合战舰STM32开发板）扩展实验5 ATK-SIM900A GSM模块测试实验/USER/main.c",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/HARDWARE/LD3320/Reg_RW.c",
		"/F/中转站/desktop-fake/省赛/program/example/库函数版本-（适合战舰STM32开发板）扩展实验5 ATK-SIM900A GSM模块测试实验/LD3320/LD3320_config.h",
		"/F/中转站/desktop-fake/省赛/program/example/库函数版本-（适合战舰STM32开发板）扩展实验5 ATK-SIM900A GSM模块测试实验/LD3320/LD3320_main.c",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/HARDWARE/LD3320/LD3320_main.c",
		"/F/中转站/desktop-fake/SmartWatch8.7/HARDWARE/TFT/LcdLib.c",
		"/F/中转站/desktop-fake/省赛/program/code/image.c",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/HARDWARE/Flash/spi_flash.h",
		"/F/中转站/desktop-fake/省赛/program/SmartWatch/HARDWARE/Flash/spi_flash.c",
		"/C/Users/zhx/AppData/Local/Temp/Rar$DI01.627/Touch.c",
		"/C/Users/zhx/AppData/Local/Temp/Rar$DI05.509/main.c",
		"/F/中转站/desktop-fake/TEST/USER/main.c",
		"/F/中转站/desktop-fake/key.h",
		"/F/中转站/desktop-fake/key.c",
		"/F/中转站/desktop-fake/省赛/program/code/test/keytest.c",
		"/F/中转站/desktop-fake/省赛/program/code/test/key.h",
		"/F/单片机/51单片机程序/Elevator/src/command.h"
	],
	"find":
	{
		"height": 35.0
	},
	"find_in_files":
	{
		"height": 102.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": true,
		"find_history":
		[
			"waittime",
			"500",
			"TEXT_NUMS",
			"data3",
			"port",
			"27",
			"refresh",
			"resfr",
			"上",
			"Show_Ch_Message",
			"LIGHTBLUE",
			"void",
			"str1",
			"ma2",
			"mima",
			"ma2",
			"mima",
			"resh",
			"+1",
			"char",
			"sim900a_get_time",
			"LD_ASR_FOUNDZERO",
			"LD_ASR_FOUNDOK",
			"B8",
			"state",
			"c",
			"command",
			"LD_AsrStart",
			"LD_Check_ASRBusyFlag_b2",
			"0x1C",
			"MIC_VOL",
			"LD_AsrStart",
			"LD_Init_ASR",
			"LD_Init_Common",
			"B3",
			"VAD",
			"12",
			"m_",
			"SHIFT_BT",
			"temp",
			"date",
			"Dis_Bt_Time_Or_Date",
			"RE_WRITE_BG",
			"voice",
			"j",
			"i",
			"76",
			"Display_Date",
			"TIME",
			"cmd",
			"ref",
			"temperature",
			"spri",
			"refresh",
			"DOOR",
			"22-16",
			"30",
			"门",
			"22,22-16,",
			"22,22,",
			"22,",
			"2",
			"AIR_CONDITIONER",
			"空调",
			"OFF",
			"BORDER_OFF_COLOR",
			"LIVING_ROOM_LIGHT",
			"71",
			"客厅",
			"22+71-8-16",
			"22,22+71-8-16",
			"22+71-8-16",
			"1000",
			"空调",
			"22,22",
			"AIR_CONDITIONER",
			"22,22",
			"空调",
			"发",
			"dev_state",
			"sim900a_send_ctrl(TXdatabuf)",
			"databuf",
			"LIGHTBLUE",
			"Rxdatabuf",
			"TXdatabufTemp",
			"databuf",
			"Draw_Block_Color",
			"LIGHTBLUE",
			"databuf",
			"Ctrl_Pannel_Touch_Handler",
			"TXdatabufTemp",
			"databuf",
			"TXdatabuf",
			"sim900a_send_data",
			"uint8",
			"Voice_Switch",
			"LD_Init_ASR",
			"85",
			"80",
			"v",
			"gImage",
			"15",
			"指令识别成功",
			"Ctrl_Pannel_Touch_Release_FdBack",
			"loop",
			"HOLD",
			"CLEAR",
			"HOLD",
			"WHITE",
			"BLACK",
			"LIGHTBLUE",
			"5+",
			"TouchVal",
			"BLACK",
			"137",
			"SPI_FLASH_WaitForWriteEnd",
			"SPI_FLASH_SendByte",
			"GB2312Code32x32",
			"WHITE",
			"LIGHTBLUE",
			"flagShowIcons",
			"Border",
			"Line",
			"GB",
			"149",
			"152",
			"110",
			"107"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": true,
		"replace_history":
		[
			"27",
			"data",
			"char *p[200];	 \n	char str1[33];\n    for(i=0;i<32;i++)\n    {\n	    str1[i] =sim900a_hex2chr(data[i]);\n    }\n    str1[32]='\\\"';\n    sprintf((char*)p,\"AT+HTTPPARA=\\\"URL\\\",\\\"http://2.smsfx.sinaapp.com/send.php?tel=%s&pwd=%s&aim=%s&text=\",TXPhoneNum,FeixinPwd,RXPhoneNum);\n    // sprintf((char*)p,\"at^siss=1,address,http://2.smsfx.sinaapp.com/send.php?tel=%s&pwd=%s&aim=%s&text=\",ma1,mima,ma2);\n    sim900a_send_cmd(\"AT+HTTPTERM\",\"OK\",200);					\n	sim900a_send_cmd(\"AT+HTTPINIT\",\"OK\",200);\n	sim900a_send_cmd(\"AT+HTTPPARA=\\\"CID\\\",1\",\"OK\",200);\n	sim900a_send1_cmd((u8*)p,\"ok\",10);\n	SetNull((u8*)p);	\n    sim900a_send_cmd((u8*)str1,\"OK\",200);				 \n	if(sim900a_send_cmd(\"AT+HTTPACTION=0\",\"OK\",200)==0)   return 0; \n	return 1;",
			"WINDOW",
			"22-16+142",
			"30+142",
			"窗",
			"22+57,22-16,",
			"22+57,30,",
			"22+57,22-16",
			"22+57,30,",
			"DOOR",
			"门",
			"BEDROOM_LIGHT",
			"142",
			"卧室",
			"22,22-16+71",
			"22-16+71",
			"SHIFT_TIME",
			"客厅灯",
			"22,22+71-8",
			"LIVING_ROOM_LIGHT",
			"22,22+71-8",
			"客厅灯",
			"block_state",
			"sim900a_send_ctrl(TXdatabuf,RXdatabuf)",
			"RXdatabuf",
			"TXdatabuf",
			"Fill_Block_Color",
			"RXdatabuf",
			"TXdatabuf",
			"sim900a_send_ctrl",
			"u8",
			"VoiceSwitch",
			"SET",
			"RESET",
			"SET",
			"IconTouchVal",
			"gImage_setting1",
			"gImage_remote1",
			"gImage_bg1",
			"TouchCountMs",
			"Touch",
			"touch",
			"TOUCH",
			"SET",
			"RESET",
			"keyValue",
			"KEY_STATE_1DOWN",
			"TouchSwitch",
			"KEY_STATE_PRESS_HOLD",
			"0XF8,0X00",
			"HOLD",
			"CLEAR",
			"BORDER_COLOR",
			" ",
			"KEEP_BG",
			"KEY_BOARD_COLOR"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"folders":
	[
		{
			"follow_symlinks": true,
			"path": "F:\\中转站\\desktop-fake\\省赛\\program\\SmartWatch"
		}
	],
	"groups":
	[
		{
			"selected": 4,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "HARDWARE/SIM900A/sim900a.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10720,
						"regions":
						{
						},
						"selection":
						[
							[
								6283,
								6283
							]
						],
						"settings":
						{
							"encoding_helper_encoding": "GB2312",
							"in_converting": true,
							"origin_encoding": "GBK",
							"revert_to_scratch": true,
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 4989.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "USER/main.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3405,
						"regions":
						{
						},
						"selection":
						[
							[
								3403,
								3403
							]
						],
						"settings":
						{
							"encoding_helper_encoding": "GB2312",
							"force_encoding": "GBK",
							"in_converting": true,
							"origin_encoding": "GBK",
							"revert_to_scratch": true,
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 2949.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "USER/remote.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 27200,
						"regions":
						{
						},
						"selection":
						[
							[
								7343,
								7343
							]
						],
						"settings":
						{
							"encoding_helper_encoding": "GB2312",
							"in_converting": true,
							"origin_encoding": "GBK",
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 799.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "HARDWARE/SIM900A/sim900a.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1258,
						"regions":
						{
						},
						"selection":
						[
							[
								97,
								97
							]
						],
						"settings":
						{
							"encoding_helper_encoding": "GB2312",
							"in_converting": true,
							"origin_encoding": "GBK",
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "HARDWARE/TFT/LcdLib.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 30341,
						"regions":
						{
						},
						"selection":
						[
							[
								29991,
								29991
							]
						],
						"settings":
						{
							"encoding_helper_encoding": "GB2312",
							"in_converting": true,
							"origin_encoding": "GBK",
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 4351.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 27.0
	},
	"input":
	{
		"height": 35.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": false,
	"output.exec":
	{
		"height": 118.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"project": "",
	"replace":
	{
		"height": 64.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"selected_items":
		[
			[
				"rtc.h",
				"HARDWARE\\RTC\\rtc.h"
			],
			[
				"rtc.c",
				"HARDWARE\\RTC\\rtc.c"
			],
			[
				"remot",
				"USER\\remote.c"
			],
			[
				"lcdl",
				"HARDWARE\\TFT\\lcdlib.h"
			],
			[
				"li",
				"HARDWARE\\TFT\\LcdLib.c"
			],
			[
				"sim",
				"HARDWARE\\SIM900A\\sim900a.h"
			],
			[
				"key.h",
				"HARDWARE\\KEY\\key.h"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": false,
	"side_bar_width": 224.0,
	"status_bar_visible": false,
	"template_settings":
	{
	}
}
